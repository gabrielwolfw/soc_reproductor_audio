
audio.elf:     file format elf32-littlenios2
audio.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x0000c180

Program Header:
    LOAD off    0x00001000 vaddr 0x0000c000 paddr 0x0000c000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001020 vaddr 0x0000c020 paddr 0x0000c020 align 2**12
         filesz 0x00001590 memsz 0x00001590 flags r-x
    LOAD off    0x000025b0 vaddr 0x0000d5b0 paddr 0x0000e69c align 2**12
         filesz 0x000010ec memsz 0x000010ec flags rw-
    LOAD off    0x00003788 vaddr 0x0000f788 paddr 0x0000f788 align 2**12
         filesz 0x00000000 memsz 0x0000013c flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  0000c000  0000c000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   00000160  0000c020  0000c020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         00001278  0000c180  0000c180  00001180  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       000001b8  0000d3f8  0000d3f8  000023f8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       000010ec  0000d5b0  0000e69c  000025b0  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          0000013c  0000f788  0000f788  00003788  2**2
                  ALLOC, SMALL_DATA
  6 .SHARED_MEMORY 00000000  00000000  00000000  0000369c  2**0
                  CONTENTS
  7 .RAM          00000000  0000f8c4  0000f8c4  0000369c  2**0
                  CONTENTS
  8 .comment      00000023  00000000  00000000  0000369c  2**0
                  CONTENTS, READONLY
  9 .debug_aranges 000003c8  00000000  00000000  000036c0  2**3
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_info   000038cc  00000000  00000000  00003a88  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 00001994  00000000  00000000  00007354  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   00001854  00000000  00000000  00008ce8  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_frame  00000594  00000000  00000000  0000a53c  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    000014fa  00000000  00000000  0000aad0  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_loc    000012a2  00000000  00000000  0000bfca  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_alt_sim_info 00000010  00000000  00000000  0000d26c  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_ranges 00000288  00000000  00000000  0000d280  2**3
                  CONTENTS, READONLY, DEBUGGING
 18 .thread_model 00000003  00000000  00000000  0000ebd6  2**0
                  CONTENTS, READONLY
 19 .cpu          00000004  00000000  00000000  0000ebd9  2**0
                  CONTENTS, READONLY
 20 .qsys         00000001  00000000  00000000  0000ebdd  2**0
                  CONTENTS, READONLY
 21 .simulation_enabled 00000001  00000000  00000000  0000ebde  2**0
                  CONTENTS, READONLY
 22 .stderr_dev   00000009  00000000  00000000  0000ebdf  2**0
                  CONTENTS, READONLY
 23 .stdin_dev    00000009  00000000  00000000  0000ebe8  2**0
                  CONTENTS, READONLY
 24 .stdout_dev   00000009  00000000  00000000  0000ebf1  2**0
                  CONTENTS, READONLY
 25 .sopc_system_name 00000008  00000000  00000000  0000ebfa  2**0
                  CONTENTS, READONLY
 26 .quartus_project_dir 00000037  00000000  00000000  0000ec02  2**0
                  CONTENTS, READONLY
 27 .jdi          0000498f  00000000  00000000  0000ec39  2**0
                  CONTENTS, READONLY
 28 .sopcinfo     0028b3fe  00000000  00000000  000135c8  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
0000c000 l    d  .entry	00000000 .entry
0000c020 l    d  .exceptions	00000000 .exceptions
0000c180 l    d  .text	00000000 .text
0000d3f8 l    d  .rodata	00000000 .rodata
0000d5b0 l    d  .rwdata	00000000 .rwdata
0000f788 l    d  .bss	00000000 .bss
00000000 l    d  .SHARED_MEMORY	00000000 .SHARED_MEMORY
0000f8c4 l    d  .RAM	00000000 .RAM
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../audio_bsp//obj/HAL/src/crt0.o
0000c1b8 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 alt_instruction_exception_entry.c
00000000 l    df *ABS*	00000000 hello_world_small.c
0000c1bc l     F .text	000000f4 audio_ir_handler
0000f788 l     O .bss	00000004 audio_counter.1889
0000e670 l     O .rwdata	00000002 amplitude.1890
0000c37c l     F .text	00000070 timer_ir_handler
00000000 l    df *ABS*	00000000 lib2-divmod.c
00000000 l    df *ABS*	00000000 lib2-mul.c
00000000 l    df *ABS*	00000000 alt_irq_register.c
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_load.c
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_printf.c
00000000 l    df *ABS*	00000000 alt_putchar.c
00000000 l    df *ABS*	00000000 alt_putstr.c
00000000 l    df *ABS*	00000000 alt_sys_init.c
0000d5b0 l     O .rwdata	00000030 AUDIO
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_init.c
0000cc74 l     F .text	00000048 altera_avalon_jtag_uart_timeout
0000ccbc l     F .text	000000e8 altera_avalon_jtag_uart_irq
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev.c
0000d038 l     F .text	00000008 alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 strlen.c
0000f7bc g     O .bss	00000004 alt_instruction_exception_handler
0000ca04 g     F .text	0000002c alt_main
0000f7c4 g     O .bss	00000100 alt_irq
0000e69c g       *ABS*	00000000 __flash_rwdata_start
0000f79c g     O .bss	00000004 elapsed_seconds
0000cbe8 g     F .text	00000038 alt_putstr
0000d19c g     F .text	00000008 altera_nios2_gen2_irq_init
0000c000 g     F .entry	0000000c __reset
0000c020 g       *ABS*	00000000 __flash_exceptions_start
0000f7c0 g     O .bss	00000004 errno
0000f7ac g     O .bss	00000004 alt_argv
00016670 g       *ABS*	00000000 _gp
0000e618 g     O .rwdata	00000030 alt_fd_list
0000d218 g     F .text	00000148 memcpy
0000d1a4 g     F .text	00000074 alt_exception_cause_generated_bad_addr
0000c3ec g     F .text	00000034 init_audio
0000c7ac g     F .text	00000064 .hidden __udivsi3
0000e67c g     O .rwdata	00000004 alt_max_fd
0000c890 g     F .text	00000094 alt_irq_register
0000f8c4 g       *ABS*	00000000 __bss_end
0000d0e4 g     F .text	000000b8 alt_tick
0000d0b0 g     F .text	00000034 alt_alarm_stop
0000f7a4 g     O .bss	00000004 alt_irq_active
0000c0fc g     F .exceptions	00000060 alt_irq_handler
0000e648 g     O .rwdata	00000028 alt_dev_null
0000c4a8 g     F .text	0000005c previous_track
0000d034 g     F .text	00000004 alt_dcache_flush_all
0000e69c g       *ABS*	00000000 __ram_rwdata_end
0000e680 g     O .rwdata	00000008 alt_dev_list
0000d5e0 g     O .rwdata	00001038 JTAG_UART
0000d5b0 g       *ABS*	00000000 __ram_rodata_end
0000c810 g     F .text	00000058 .hidden __umodsi3
0000f8c4 g       *ABS*	00000000 end
0000cda4 g     F .text	00000070 altera_avalon_jtag_uart_init
0000c15c g     F .exceptions	00000024 alt_instruction_exception_entry
00010000 g       *ABS*	00000000 __alt_stack_pointer
0000ce44 g     F .text	00000170 altera_avalon_jtag_uart_write
0000ca30 g     F .text	00000170 alt_printf
0000c504 g     F .text	000000a0 handle_buttons
0000c180 g     F .text	0000003c _start
0000f7b8 g     O .bss	00000004 _alt_tick_rate
0000f7b4 g     O .bss	00000004 _alt_nticks
0000cc40 g     F .text	00000034 alt_sys_init
00000000 g       *ABS*	00000000 __alt_mem_SHARED_MEMORY
0000ce14 g     F .text	00000030 altera_avalon_jtag_uart_close
0000c868 g     F .text	00000028 .hidden __mulsi3
0000d5b0 g       *ABS*	00000000 __ram_rwdata_start
0000d3f8 g       *ABS*	00000000 __ram_rodata_start
0000f78c g     O .bss	00000004 prev_button_state
0000e674 g     O .rwdata	00000004 current_track
0000c2b0 g     F .text	000000cc update_seven_segment_display
0000f8c4 g       *ABS*	00000000 __alt_stack_base
0000d040 g     F .text	0000006c alt_dev_llist_insert
0000f788 g       *ABS*	00000000 __bss_start
0000c5a4 g     F .text	00000110 main
0000c000 g       *ABS*	00000000 __alt_mem_RAM
0000f7a8 g     O .bss	00000004 alt_envp
0000c420 g     F .text	00000018 play_audio
0000e690 g     O .rwdata	00000004 alt_errno
0000d58b g     O .rodata	0000000a seven_seg_patterns
0000c6b4 g     F .text	00000084 .hidden __divsi3
0000d3f8 g       *ABS*	00000000 __flash_rodata_start
0000cc20 g     F .text	00000020 alt_irq_init
0000c448 g     F .text	00000060 next_track
0000f790 g     O .bss	00000004 button_state
0000f7b0 g     O .bss	00000004 alt_argc
0000c020 g       .exceptions	00000000 alt_irq_entry
0000e688 g     O .rwdata	00000008 alt_fs_list
0000c020 g       *ABS*	00000000 __ram_exceptions_start
0000f798 g     O .bss	00000004 elapsed_minutes
0000e69c g       *ABS*	00000000 _edata
0000c438 g     F .text	00000010 pause_audio
0000f8c4 g       *ABS*	00000000 _end
0000c180 g       *ABS*	00000000 __ram_exceptions_end
0000c738 g     F .text	00000074 .hidden __modsi3
00010000 g       *ABS*	00000000 __alt_data_end
0000c020 g     F .exceptions	00000000 alt_exception
0000c00c g       .entry	00000000 _exit
0000cfb4 g     F .text	00000080 alt_alarm_start
0000d360 g     F .text	00000098 strlen
0000cba0 g     F .text	00000048 alt_putchar
0000f794 g     O .bss	00000004 is_playing
0000d0ac g     F .text	00000004 alt_icache_flush_all
0000e678 g     O .rwdata	00000004 alt_priority_mask
0000e694 g     O .rwdata	00000008 alt_alarm_list
0000f7a0 g     O .bss	00000004 elapsed_ms
0000c924 g     F .text	000000e0 alt_load



Disassembly of section .entry:

0000c000 <__reset>:
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
    c000:	00400034 	movhi	at,0
    ori r1, r1, %lo(_start)
    c004:	08706014 	ori	at,at,49536
    jmp r1
    c008:	0800683a 	jmp	at

0000c00c <_exit>:
	...

Disassembly of section .exceptions:

0000c020 <alt_exception>:

#else /* ALT_EXCEPTION_STACK disabled */
        /* 
         * Reserve space on normal stack for registers about to be pushed.
         */
        addi  sp, sp, -76
    c020:	deffed04 	addi	sp,sp,-76
         * documentation for details).
         *
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */
        stw   ra,  0(sp)
    c024:	dfc00015 	stw	ra,0(sp)
        stw   r1,   8(sp)
    c028:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
    c02c:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
    c030:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
    c034:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
    c038:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
    c03c:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
    c040:	d9c00815 	stw	r7,32(sp)
        rdctl r5, estatus   /* Read early to avoid usage stall */
    c044:	000b307a 	rdctl	r5,estatus
        stw   r8,  36(sp)
    c048:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
    c04c:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
    c050:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
    c054:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
    c058:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
    c05c:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
    c060:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
    c064:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
    c068:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
    c06c:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
    c070:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
    c074:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
    c078:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
    c07c:	10000326 	beq	r2,zero,c08c <alt_exception+0x6c>
        beq   r4, zero, .Lnot_irq
    c080:	20000226 	beq	r4,zero,c08c <alt_exception+0x6c>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
    c084:	000c0fc0 	call	c0fc <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
    c088:	00000706 	br	c0a8 <alt_exception+0x88>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw ea, 72(sp) /* EA is PC+4 so will skip over instruction causing exception */
    c08c:	df401215 	stw	ea,72(sp)
.Lunknown_16bit:
        addi.n r4, r4, 2 /* Need PC+2 to skip over instruction causing exception */
        stw r4, 72(sp)

#else /* CDX is not Enabled and all instructions are 32bits */
        ldw r2, -4(ea) /* Instruction value that caused exception */
    c090:	e8bfff17 	ldw	r2,-4(ea)
         * debugger is present) or go into an infinite loop since the
         * handling behavior is undefined; in that case we will not return here.
         */

        /* Load exception-causing address as first argument (r4) */
        addi   r4, ea, -4
    c094:	e93fff04 	addi	r4,ea,-4

        /* Call the instruction-exception entry */
        call   alt_instruction_exception_entry
    c098:	000c15c0 	call	c15c <alt_instruction_exception_entry>
         * instruction
         *
         * Return code was 0: Skip. The instruction after the exception is
         * already stored in 72(sp).
         */
        bne   r2, r0, .Lexception_exit
    c09c:	1000021e 	bne	r2,zero,c0a8 <alt_exception+0x88>

        /*
         * Otherwise, modify 72(sp) to re-issue the instruction that caused the
         * exception.
         */
        addi  r15, ea, -4  /* instruction that caused exception */
    c0a0:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
    c0a4:	dbc01215 	stw	r15,72(sp)
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
    c0a8:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
    c0ac:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
    c0b0:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
    c0b4:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
    c0b8:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
    c0bc:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
    c0c0:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
    c0c4:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
    c0c8:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
    c0cc:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
    c0d0:	d9c00817 	ldw	r7,32(sp)

#if defined(ALT_EXCEPTION_STACK) && defined(ALT_STACK_CHECK)
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif

        ldw   r8,  36(sp)
    c0d4:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
    c0d8:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
    c0dc:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
    c0e0:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
    c0e4:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
    c0e8:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
    c0ec:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
    c0f0:	dbc01017 	ldw	r15,64(sp)
        stw   et, %gprel(alt_stack_limit_value)(gp)
        stw   zero, %gprel(alt_exception_old_stack_limit)(gp)
#endif /* ALT_STACK_CHECK */
        ldw   sp,  76(sp)
#else /* ALT_EXCEPTION_STACK disabled */
        addi  sp, sp, 76
    c0f4:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
    c0f8:	ef80083a 	eret

0000c0fc <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
    c0fc:	defffe04 	addi	sp,sp,-8
    c100:	dfc00115 	stw	ra,4(sp)
    c104:	dc000015 	stw	r16,0(sp)
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
    c108:	0007313a 	rdctl	r3,ipending
      if (active & mask)
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
    c10c:	04000074 	movhi	r16,1
    c110:	843df104 	addi	r16,r16,-2108

  active = alt_irq_pending ();

  do
  {
    i = 0;
    c114:	000b883a 	mov	r5,zero
    mask = 1;
    c118:	00800044 	movi	r2,1
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
    c11c:	1888703a 	and	r4,r3,r2
    c120:	20000b26 	beq	r4,zero,c150 <alt_irq_handler+0x54>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
    c124:	280490fa 	slli	r2,r5,3
    c128:	8085883a 	add	r2,r16,r2
    c12c:	10c00017 	ldw	r3,0(r2)
    c130:	11000117 	ldw	r4,4(r2)
    c134:	183ee83a 	callr	r3
    c138:	0007313a 	rdctl	r3,ipending

    } while (1);

    active = alt_irq_pending ();
    
  } while (active);
    c13c:	183ff51e 	bne	r3,zero,c114 <_gp+0xffff5aa4>
  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
}
    c140:	dfc00117 	ldw	ra,4(sp)
    c144:	dc000017 	ldw	r16,0(sp)
    c148:	dec00204 	addi	sp,sp,8
    c14c:	f800283a 	ret
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
      }
      mask <<= 1;
    c150:	1085883a 	add	r2,r2,r2
      i++;
    c154:	29400044 	addi	r5,r5,1

    } while (1);
    c158:	003ff006 	br	c11c <_gp+0xffff5aac>

0000c15c <alt_instruction_exception_entry>:
#else
  cause = NIOS2_EXCEPTION_CAUSE_NOT_PRESENT;
  badaddr = 0;
#endif /* NIOS2_HAS_EXTRA_EXCEPTION_INFO */

  if(alt_instruction_exception_handler) {
    c15c:	d0a45317 	ldw	r2,-28340(gp)
    c160:	10000426 	beq	r2,zero,c174 <alt_instruction_exception_entry+0x18>
     * Call handler. Its return value indicates whether the exception-causing
     * instruction should be re-issued. The code that called us,
     * alt_eceptions_entry.S, will look at this value and adjust the ea
     * register as necessary
     */
    return alt_instruction_exception_handler(cause, exception_pc, badaddr);
    c164:	200b883a 	mov	r5,r4
    c168:	000d883a 	mov	r6,zero
    c16c:	013fffc4 	movi	r4,-1
    c170:	1000683a 	jmp	r2
   *    (a peripheral which negates its interrupt output before its
   *    interrupt handler has been executed will cause spurious interrupts)
   */
  else {
#ifdef NIOS2_HAS_DEBUG_STUB
    NIOS2_BREAK();
    c174:	003da03a 	break	0
#endif /* NIOS2_HAS_DEBUG_STUB */
  }

  /* We should not get here. Remove compiler warning. */
  return NIOS2_EXCEPTION_RETURN_REISSUE_INST;
}
    c178:	0005883a 	mov	r2,zero
    c17c:	f800283a 	ret

Disassembly of section .text:

0000c180 <_start>:

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
    c180:	06c00074 	movhi	sp,1
    ori sp, sp, %lo(__alt_stack_pointer)
    c184:	dec00014 	ori	sp,sp,0
    movhi gp, %hi(_gp)
    c188:	06800074 	movhi	gp,1
    ori gp, gp, %lo(_gp)
    c18c:	d6999c14 	ori	gp,gp,26224
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
    c190:	00800034 	movhi	r2,0
    ori r2, r2, %lo(__bss_start)
    c194:	10bde214 	ori	r2,r2,63368

    movhi r3, %hi(__bss_end)
    c198:	00c00034 	movhi	r3,0
    ori r3, r3, %lo(__bss_end)
    c19c:	18fe3114 	ori	r3,r3,63684

    beq r2, r3, 1f
    c1a0:	10c00326 	beq	r2,r3,c1b0 <_start+0x30>

0:
    stw zero, (r2)
    c1a4:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
    c1a8:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
    c1ac:	10fffd36 	bltu	r2,r3,c1a4 <_gp+0xffff5b34>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
    c1b0:	000c9240 	call	c924 <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
    c1b4:	000ca040 	call	ca04 <alt_main>

0000c1b8 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
    c1b8:	003fff06 	br	c1b8 <_gp+0xffff5b48>

0000c1bc <audio_ir_handler>:
    // Registros específicos del IP de Audio de Altera
    volatile unsigned int* fifospace_reg = (unsigned int*)(AUDIO_BASE + 4);   // FIFOSPACE
    volatile unsigned int* leftdata_reg = (unsigned int*)(AUDIO_BASE + 8);    // LEFTDATA
    volatile unsigned int* rightdata_reg = (unsigned int*)(AUDIO_BASE + 12);  // RIGHTDATA

    if (is_playing) {
    c1bc:	d0a44917 	ldw	r2,-28380(gp)
    c1c0:	10003a26 	beq	r2,zero,c2ac <audio_ir_handler+0xf0>
        // Leer espacio disponible en FIFO
        unsigned int fifospace = *fifospace_reg;
    c1c4:	00800074 	movhi	r2,1
    c1c8:	10841104 	addi	r2,r2,4164
    c1cc:	10800017 	ldw	r2,0(r2)
        unsigned int wsrc = (fifospace & 0x00FF0000) >> 16;  // Write space right channel
        unsigned int wslc = (fifospace & 0xFF000000) >> 24;  // Write space left channel

        // Si hay espacio en ambos canales, enviar datos
        if (wsrc > 0 && wslc > 0) {
    c1d0:	10c03fec 	andhi	r3,r2,255
    c1d4:	18003526 	beq	r3,zero,c2ac <audio_ir_handler+0xf0>
    c1d8:	1004d63a 	srli	r2,r2,24
    c1dc:	10003326 	beq	r2,zero,c2ac <audio_ir_handler+0xf0>
            // Generar audio de prueba (tono simple)
            static unsigned int audio_counter = 0;
            static short amplitude = 8000;  // Amplitud del tono

            // Generar tono de prueba basado en el track actual
            unsigned int frequency = 440 + (current_track - 1) * 110;  // A4 + intervalos
    c1e0:	d1200117 	ldw	r4,-32764(gp)
        }
    }
}

// MEJORADO: audio_ir_handler con funcionalidad real
static void audio_ir_handler(void * context, alt_u32 id) {
    c1e4:	defffd04 	addi	sp,sp,-12
            // Generar audio de prueba (tono simple)
            static unsigned int audio_counter = 0;
            static short amplitude = 8000;  // Amplitud del tono

            // Generar tono de prueba basado en el track actual
            unsigned int frequency = 440 + (current_track - 1) * 110;  // A4 + intervalos
    c1e8:	01401b84 	movi	r5,110
        }
    }
}

// MEJORADO: audio_ir_handler con funcionalidad real
static void audio_ir_handler(void * context, alt_u32 id) {
    c1ec:	dfc00215 	stw	ra,8(sp)
    c1f0:	dc400115 	stw	r17,4(sp)
    c1f4:	dc000015 	stw	r16,0(sp)
            // Generar audio de prueba (tono simple)
            static unsigned int audio_counter = 0;
            static short amplitude = 8000;  // Amplitud del tono

            // Generar tono de prueba basado en el track actual
            unsigned int frequency = 440 + (current_track - 1) * 110;  // A4 + intervalos
    c1f8:	000c8680 	call	c868 <__mulsi3>
    c1fc:	14005284 	addi	r16,r2,330
            short sample = (short)(amplitude *
    c200:	800b883a 	mov	r5,r16
    c204:	012ee014 	movui	r4,48000
    c208:	000c7ac0 	call	c7ac <__udivsi3>
    c20c:	d1244617 	ldw	r4,-28392(gp)
    c210:	100b883a 	mov	r5,r2
    c214:	000c8100 	call	c810 <__umodsi3>
    c218:	800b883a 	mov	r5,r16
    c21c:	01177004 	movi	r4,24000
    c220:	1023883a 	mov	r17,r2
    c224:	000c7ac0 	call	c7ac <__udivsi3>
    c228:	88800236 	bltu	r17,r2,c234 <audio_ir_handler+0x78>
    c22c:	017fffc4 	movi	r5,-1
    c230:	00000106 	br	c238 <audio_ir_handler+0x7c>
    c234:	01400044 	movi	r5,1
    c238:	d420000b 	ldhu	r16,-32768(gp)
                          (audio_counter % (48000 / frequency) < (48000 / frequency / 2) ? 1 : -1));

            // Enviar muestra a ambos canales
            *leftdata_reg = sample;
    c23c:	8009883a 	mov	r4,r16
    c240:	000c8680 	call	c868 <__mulsi3>
    c244:	10bfffcc 	andi	r2,r2,65535
    c248:	00c00074 	movhi	r3,1
    c24c:	10a0001c 	xori	r2,r2,32768
    c250:	10a00004 	addi	r2,r2,-32768
    c254:	18c41204 	addi	r3,r3,4168
    c258:	18800015 	stw	r2,0(r3)
            *rightdata_reg = sample;
    c25c:	00c00074 	movhi	r3,1
    c260:	18c41304 	addi	r3,r3,4172
    c264:	18800015 	stw	r2,0(r3)

            audio_counter++;
    c268:	d1244617 	ldw	r4,-28392(gp)

            // Cambiar frecuencia cada cierto tiempo para crear melodía simple
            if (audio_counter % 48000 == 0) {  // Cada segundo
    c26c:	016ee014 	movui	r5,48000

            // Enviar muestra a ambos canales
            *leftdata_reg = sample;
            *rightdata_reg = sample;

            audio_counter++;
    c270:	21000044 	addi	r4,r4,1
    c274:	d1244615 	stw	r4,-28392(gp)

            // Cambiar frecuencia cada cierto tiempo para crear melodía simple
            if (audio_counter % 48000 == 0) {  // Cada segundo
    c278:	000c8100 	call	c810 <__umodsi3>
    c27c:	1000071e 	bne	r2,zero,c29c <audio_ir_handler+0xe0>
                amplitude = (amplitude == 8000) ? 4000 : 8000;  // Variar volumen
    c280:	843fffcc 	andi	r16,r16,65535
    c284:	8420001c 	xori	r16,r16,32768
    c288:	84200004 	addi	r16,r16,-32768
    c28c:	0087d004 	movi	r2,8000
    c290:	8080011e 	bne	r16,r2,c298 <audio_ir_handler+0xdc>
    c294:	0083e804 	movi	r2,4000
    c298:	d0a0000d 	sth	r2,-32768(gp)
    }

    // El IP de Audio de Altera típicamente no requiere limpiar interrupciones manualmente
    // pero si es necesario, sería algo como:
    // *audio_ptr = *audio_ptr;  // Leer para limpiar
}
    c29c:	dfc00217 	ldw	ra,8(sp)
    c2a0:	dc400117 	ldw	r17,4(sp)
    c2a4:	dc000017 	ldw	r16,0(sp)
    c2a8:	dec00304 	addi	sp,sp,12
    c2ac:	f800283a 	ret

0000c2b0 <update_seven_segment_display>:
    }

    prev_button_state = button_state;
}

void update_seven_segment_display(void) {
    c2b0:	defffa04 	addi	sp,sp,-24
    c2b4:	dcc00315 	stw	r19,12(sp)
    volatile unsigned int * sevenseg_ptr = (unsigned int *) SEVEN_SEGMENTS_BASE;

    // Extraer dígitos para MM:SS format
    unsigned char min_tens = elapsed_minutes / 10;
    c2b8:	d4e44a17 	ldw	r19,-28376(gp)
    unsigned char min_ones = elapsed_minutes % 10;
    c2bc:	d1244a17 	ldw	r4,-28376(gp)
    }

    prev_button_state = button_state;
}

void update_seven_segment_display(void) {
    c2c0:	dd000415 	stw	r20,16(sp)
    c2c4:	dc800215 	stw	r18,8(sp)
    c2c8:	dc400115 	stw	r17,4(sp)
    volatile unsigned int * sevenseg_ptr = (unsigned int *) SEVEN_SEGMENTS_BASE;

    // Extraer dígitos para MM:SS format
    unsigned char min_tens = elapsed_minutes / 10;
    unsigned char min_ones = elapsed_minutes % 10;
    unsigned char sec_tens = elapsed_seconds / 10;
    c2cc:	d4a44b17 	ldw	r18,-28372(gp)

    // El display tiene 28 bits de ancho (4 displays de 7 bits cada uno)
    // HEX3[27:21] | HEX2[20:14] | HEX1[13:7] | HEX0[6:0]
    unsigned int display_value =
        ((unsigned int)seven_seg_patterns[min_tens] << 21) |  // HEX3
        ((unsigned int)seven_seg_patterns[min_ones] << 14) |  // HEX2
    c2d0:	01400284 	movi	r5,10

    // Extraer dígitos para MM:SS format
    unsigned char min_tens = elapsed_minutes / 10;
    unsigned char min_ones = elapsed_minutes % 10;
    unsigned char sec_tens = elapsed_seconds / 10;
    unsigned char sec_ones = elapsed_seconds % 10;
    c2d4:	d5244b17 	ldw	r20,-28372(gp)

    // El display tiene 28 bits de ancho (4 displays de 7 bits cada uno)
    // HEX3[27:21] | HEX2[20:14] | HEX1[13:7] | HEX0[6:0]
    unsigned int display_value =
        ((unsigned int)seven_seg_patterns[min_tens] << 21) |  // HEX3
        ((unsigned int)seven_seg_patterns[min_ones] << 14) |  // HEX2
    c2d8:	04400074 	movhi	r17,1
    }

    prev_button_state = button_state;
}

void update_seven_segment_display(void) {
    c2dc:	dfc00515 	stw	ra,20(sp)

    // El display tiene 28 bits de ancho (4 displays de 7 bits cada uno)
    // HEX3[27:21] | HEX2[20:14] | HEX1[13:7] | HEX0[6:0]
    unsigned int display_value =
        ((unsigned int)seven_seg_patterns[min_tens] << 21) |  // HEX3
        ((unsigned int)seven_seg_patterns[min_ones] << 14) |  // HEX2
    c2e0:	8c7562c4 	addi	r17,r17,-10869
    }

    prev_button_state = button_state;
}

void update_seven_segment_display(void) {
    c2e4:	dc000015 	stw	r16,0(sp)

    // El display tiene 28 bits de ancho (4 displays de 7 bits cada uno)
    // HEX3[27:21] | HEX2[20:14] | HEX1[13:7] | HEX0[6:0]
    unsigned int display_value =
        ((unsigned int)seven_seg_patterns[min_tens] << 21) |  // HEX3
        ((unsigned int)seven_seg_patterns[min_ones] << 14) |  // HEX2
    c2e8:	000c8100 	call	c810 <__umodsi3>
    c2ec:	8885883a 	add	r2,r17,r2
    unsigned char sec_tens = elapsed_seconds / 10;
    unsigned char sec_ones = elapsed_seconds % 10;

    // El display tiene 28 bits de ancho (4 displays de 7 bits cada uno)
    // HEX3[27:21] | HEX2[20:14] | HEX1[13:7] | HEX0[6:0]
    unsigned int display_value =
    c2f0:	14000003 	ldbu	r16,0(r2)
        ((unsigned int)seven_seg_patterns[min_tens] << 21) |  // HEX3
        ((unsigned int)seven_seg_patterns[min_ones] << 14) |  // HEX2
        ((unsigned int)seven_seg_patterns[sec_tens] << 7) |   // HEX1
        ((unsigned int)seven_seg_patterns[sec_ones]);         // HEX0
    c2f4:	a009883a 	mov	r4,r20
    c2f8:	01400284 	movi	r5,10
    c2fc:	000c8100 	call	c810 <__umodsi3>
    c300:	8885883a 	add	r2,r17,r2
    unsigned char sec_tens = elapsed_seconds / 10;
    unsigned char sec_ones = elapsed_seconds % 10;

    // El display tiene 28 bits de ancho (4 displays de 7 bits cada uno)
    // HEX3[27:21] | HEX2[20:14] | HEX1[13:7] | HEX0[6:0]
    unsigned int display_value =
    c304:	10800003 	ldbu	r2,0(r2)
    c308:	802093ba 	slli	r16,r16,14
        ((unsigned int)seven_seg_patterns[min_tens] << 21) |  // HEX3
    c30c:	9809883a 	mov	r4,r19
    c310:	01400284 	movi	r5,10
    unsigned char sec_tens = elapsed_seconds / 10;
    unsigned char sec_ones = elapsed_seconds % 10;

    // El display tiene 28 bits de ancho (4 displays de 7 bits cada uno)
    // HEX3[27:21] | HEX2[20:14] | HEX1[13:7] | HEX0[6:0]
    unsigned int display_value =
    c314:	80a0b03a 	or	r16,r16,r2
        ((unsigned int)seven_seg_patterns[min_tens] << 21) |  // HEX3
    c318:	000c7ac0 	call	c7ac <__udivsi3>
    c31c:	10803fcc 	andi	r2,r2,255
    c320:	8885883a 	add	r2,r17,r2
    unsigned char sec_tens = elapsed_seconds / 10;
    unsigned char sec_ones = elapsed_seconds % 10;

    // El display tiene 28 bits de ancho (4 displays de 7 bits cada uno)
    // HEX3[27:21] | HEX2[20:14] | HEX1[13:7] | HEX0[6:0]
    unsigned int display_value =
    c324:	10800003 	ldbu	r2,0(r2)
        ((unsigned int)seven_seg_patterns[min_tens] << 21) |  // HEX3
        ((unsigned int)seven_seg_patterns[min_ones] << 14) |  // HEX2
        ((unsigned int)seven_seg_patterns[sec_tens] << 7) |   // HEX1
    c328:	01400284 	movi	r5,10
    c32c:	9009883a 	mov	r4,r18
    unsigned char sec_tens = elapsed_seconds / 10;
    unsigned char sec_ones = elapsed_seconds % 10;

    // El display tiene 28 bits de ancho (4 displays de 7 bits cada uno)
    // HEX3[27:21] | HEX2[20:14] | HEX1[13:7] | HEX0[6:0]
    unsigned int display_value =
    c330:	1004957a 	slli	r2,r2,21
    c334:	80a0b03a 	or	r16,r16,r2
        ((unsigned int)seven_seg_patterns[min_tens] << 21) |  // HEX3
        ((unsigned int)seven_seg_patterns[min_ones] << 14) |  // HEX2
        ((unsigned int)seven_seg_patterns[sec_tens] << 7) |   // HEX1
    c338:	000c7ac0 	call	c7ac <__udivsi3>
    c33c:	10803fcc 	andi	r2,r2,255
    c340:	88a3883a 	add	r17,r17,r2
    unsigned char sec_tens = elapsed_seconds / 10;
    unsigned char sec_ones = elapsed_seconds % 10;

    // El display tiene 28 bits de ancho (4 displays de 7 bits cada uno)
    // HEX3[27:21] | HEX2[20:14] | HEX1[13:7] | HEX0[6:0]
    unsigned int display_value =
    c344:	88800003 	ldbu	r2,0(r17)
        ((unsigned int)seven_seg_patterns[min_tens] << 21) |  // HEX3
        ((unsigned int)seven_seg_patterns[min_ones] << 14) |  // HEX2
        ((unsigned int)seven_seg_patterns[sec_tens] << 7) |   // HEX1
        ((unsigned int)seven_seg_patterns[sec_ones]);         // HEX0

    *sevenseg_ptr = display_value;
    c348:	00c00074 	movhi	r3,1
    c34c:	18c40c04 	addi	r3,r3,4144
    unsigned char sec_tens = elapsed_seconds / 10;
    unsigned char sec_ones = elapsed_seconds % 10;

    // El display tiene 28 bits de ancho (4 displays de 7 bits cada uno)
    // HEX3[27:21] | HEX2[20:14] | HEX1[13:7] | HEX0[6:0]
    unsigned int display_value =
    c350:	100491fa 	slli	r2,r2,7
    c354:	8084b03a 	or	r2,r16,r2
        ((unsigned int)seven_seg_patterns[min_tens] << 21) |  // HEX3
        ((unsigned int)seven_seg_patterns[min_ones] << 14) |  // HEX2
        ((unsigned int)seven_seg_patterns[sec_tens] << 7) |   // HEX1
        ((unsigned int)seven_seg_patterns[sec_ones]);         // HEX0

    *sevenseg_ptr = display_value;
    c358:	18800015 	stw	r2,0(r3)
}
    c35c:	dfc00517 	ldw	ra,20(sp)
    c360:	dd000417 	ldw	r20,16(sp)
    c364:	dcc00317 	ldw	r19,12(sp)
    c368:	dc800217 	ldw	r18,8(sp)
    c36c:	dc400117 	ldw	r17,4(sp)
    c370:	dc000017 	ldw	r16,0(sp)
    c374:	dec00604 	addi	sp,sp,24
    c378:	f800283a 	ret

0000c37c <timer_ir_handler>:

// CORREGIDO: Agregar alt_u32 id en la firma
static void timer_ir_handler(void * context, alt_u32 id) {
    // Limpiar la interrupción del timer escribiendo cualquier valor al registro de status
    volatile unsigned int* timer_status_ptr = (unsigned int *) TIMER_BASE;
    *timer_status_ptr = 0;  // Limpiar TO bit
    c37c:	00800074 	movhi	r2,1
    c380:	10840004 	addi	r2,r2,4096
    c384:	10000015 	stw	zero,0(r2)

    // Incrementar tiempo solo si está reproduciendo
    if (is_playing) {
    c388:	d0a44917 	ldw	r2,-28380(gp)
    c38c:	10001626 	beq	r2,zero,c3e8 <timer_ir_handler+0x6c>
        elapsed_ms++;
    c390:	d0a44c17 	ldw	r2,-28368(gp)
        if (elapsed_ms >= 1000) {  // 1 segundo
    c394:	00c0f9c4 	movi	r3,999
    volatile unsigned int* timer_status_ptr = (unsigned int *) TIMER_BASE;
    *timer_status_ptr = 0;  // Limpiar TO bit

    // Incrementar tiempo solo si está reproduciendo
    if (is_playing) {
        elapsed_ms++;
    c398:	10800044 	addi	r2,r2,1
    c39c:	d0a44c15 	stw	r2,-28368(gp)
        if (elapsed_ms >= 1000) {  // 1 segundo
    c3a0:	d0a44c17 	ldw	r2,-28368(gp)
    c3a4:	1880102e 	bgeu	r3,r2,c3e8 <timer_ir_handler+0x6c>
            elapsed_ms = 0;
    c3a8:	d0244c15 	stw	zero,-28368(gp)
            elapsed_seconds++;
    c3ac:	d0a44b17 	ldw	r2,-28372(gp)
            if (elapsed_seconds >= 60) {  // 1 minuto
    c3b0:	00c00ec4 	movi	r3,59
    // Incrementar tiempo solo si está reproduciendo
    if (is_playing) {
        elapsed_ms++;
        if (elapsed_ms >= 1000) {  // 1 segundo
            elapsed_ms = 0;
            elapsed_seconds++;
    c3b4:	10800044 	addi	r2,r2,1
    c3b8:	d0a44b15 	stw	r2,-28372(gp)
            if (elapsed_seconds >= 60) {  // 1 minuto
    c3bc:	d0a44b17 	ldw	r2,-28372(gp)
    c3c0:	1880082e 	bgeu	r3,r2,c3e4 <timer_ir_handler+0x68>
                elapsed_seconds = 0;
    c3c4:	d0244b15 	stw	zero,-28372(gp)
                elapsed_minutes++;
    c3c8:	d0a44a17 	ldw	r2,-28376(gp)
                if (elapsed_minutes >= 100) {  // Reset después de 99:59
    c3cc:	00c018c4 	movi	r3,99
        if (elapsed_ms >= 1000) {  // 1 segundo
            elapsed_ms = 0;
            elapsed_seconds++;
            if (elapsed_seconds >= 60) {  // 1 minuto
                elapsed_seconds = 0;
                elapsed_minutes++;
    c3d0:	10800044 	addi	r2,r2,1
    c3d4:	d0a44a15 	stw	r2,-28376(gp)
                if (elapsed_minutes >= 100) {  // Reset después de 99:59
    c3d8:	d0a44a17 	ldw	r2,-28376(gp)
    c3dc:	1880012e 	bgeu	r3,r2,c3e4 <timer_ir_handler+0x68>
                    elapsed_minutes = 0;
    c3e0:	d0244a15 	stw	zero,-28376(gp)
                }
            }
            // Actualizar display cada segundo
            update_seven_segment_display();
    c3e4:	000c2b01 	jmpi	c2b0 <update_seven_segment_display>
    c3e8:	f800283a 	ret

0000c3ec <init_audio>:
void init_audio(void) {
    volatile unsigned int * audio_ptr = (unsigned int *) AUDIO_BASE;

    // Configuración básica del IP de audio de Altera
    // Control register (offset 0) - habilitar audio
    *audio_ptr = 0x1;  // Enable bit
    c3ec:	00800074 	movhi	r2,1
    c3f0:	00c00044 	movi	r3,1
    c3f4:	10841004 	addi	r2,r2,4160
    c3f8:	10c00015 	stw	r3,0(r2)

    // Limpiar FIFOs - escribir en LEFTDATA y RIGHTDATA para inicializar
    volatile unsigned int* leftdata_reg = (unsigned int*)(AUDIO_BASE + 8);
    volatile unsigned int* rightdata_reg = (unsigned int*)(AUDIO_BASE + 12);

    *leftdata_reg = 0;
    c3fc:	00800074 	movhi	r2,1
    c400:	10841204 	addi	r2,r2,4168
    c404:	10000015 	stw	zero,0(r2)
    *rightdata_reg = 0;

    alt_putstr("Audio IP initialized\n");
    c408:	01000074 	movhi	r4,1
    // Limpiar FIFOs - escribir en LEFTDATA y RIGHTDATA para inicializar
    volatile unsigned int* leftdata_reg = (unsigned int*)(AUDIO_BASE + 8);
    volatile unsigned int* rightdata_reg = (unsigned int*)(AUDIO_BASE + 12);

    *leftdata_reg = 0;
    *rightdata_reg = 0;
    c40c:	00800074 	movhi	r2,1
    c410:	10841304 	addi	r2,r2,4172

    alt_putstr("Audio IP initialized\n");
    c414:	2134fe04 	addi	r4,r4,-11272
    // Limpiar FIFOs - escribir en LEFTDATA y RIGHTDATA para inicializar
    volatile unsigned int* leftdata_reg = (unsigned int*)(AUDIO_BASE + 8);
    volatile unsigned int* rightdata_reg = (unsigned int*)(AUDIO_BASE + 12);

    *leftdata_reg = 0;
    *rightdata_reg = 0;
    c418:	10000015 	stw	zero,0(r2)

    alt_putstr("Audio IP initialized\n");
    c41c:	000cbe81 	jmpi	cbe8 <alt_putstr>

0000c420 <play_audio>:
}

void play_audio(void) {
    // Iniciar reproducción
    is_playing = 1;
    c420:	00800044 	movi	r2,1
    c424:	d0a44915 	stw	r2,-28380(gp)
    alt_printf("Playing track %d\n", current_track);
    c428:	d1600117 	ldw	r5,-32764(gp)
    c42c:	01000074 	movhi	r4,1
    c430:	21350404 	addi	r4,r4,-11248
    c434:	000ca301 	jmpi	ca30 <alt_printf>

0000c438 <pause_audio>:
}

void pause_audio(void) {
    // Pausar reproducción
    is_playing = 0;
    alt_putstr("Audio paused\n");
    c438:	01000074 	movhi	r4,1
    c43c:	21350904 	addi	r4,r4,-11228
    alt_printf("Playing track %d\n", current_track);
}

void pause_audio(void) {
    // Pausar reproducción
    is_playing = 0;
    c440:	d0244915 	stw	zero,-28380(gp)
    alt_putstr("Audio paused\n");
    c444:	000cbe81 	jmpi	cbe8 <alt_putstr>

0000c448 <next_track>:
}

void next_track(void) {
    // Pausar audio actual
    if (is_playing) {
    c448:	d0a44917 	ldw	r2,-28380(gp)
    // Pausar reproducción
    is_playing = 0;
    alt_putstr("Audio paused\n");
}

void next_track(void) {
    c44c:	deffff04 	addi	sp,sp,-4
    c450:	dfc00015 	stw	ra,0(sp)
    // Pausar audio actual
    if (is_playing) {
    c454:	10000126 	beq	r2,zero,c45c <next_track+0x14>
        pause_audio();
    c458:	000c4380 	call	c438 <pause_audio>
    }

    current_track++;
    c45c:	d0a00117 	ldw	r2,-32764(gp)
    if (current_track > 10) {  // Máximo 10 tracks por ejemplo
    c460:	00c00284 	movi	r3,10
    // Pausar audio actual
    if (is_playing) {
        pause_audio();
    }

    current_track++;
    c464:	10800044 	addi	r2,r2,1
    c468:	d0a00115 	stw	r2,-32764(gp)
    if (current_track > 10) {  // Máximo 10 tracks por ejemplo
    c46c:	d0a00117 	ldw	r2,-32764(gp)
    c470:	1880022e 	bgeu	r3,r2,c47c <next_track+0x34>
        current_track = 1;
    c474:	00800044 	movi	r2,1
    c478:	d0a00115 	stw	r2,-32764(gp)
    }

    // Reset tiempo
    elapsed_ms = 0;
    c47c:	d0244c15 	stw	zero,-28368(gp)
    elapsed_seconds = 0;
    c480:	d0244b15 	stw	zero,-28372(gp)
    elapsed_minutes = 0;
    c484:	d0244a15 	stw	zero,-28376(gp)

    update_seven_segment_display();
    c488:	000c2b00 	call	c2b0 <update_seven_segment_display>

    alt_printf("Next track: %d\n", current_track);
    c48c:	d1600117 	ldw	r5,-32764(gp)
    c490:	01000074 	movhi	r4,1
    c494:	21350d04 	addi	r4,r4,-11212
    c498:	000ca300 	call	ca30 <alt_printf>

    // Reanudar reproducción automáticamente
    play_audio();
}
    c49c:	dfc00017 	ldw	ra,0(sp)
    c4a0:	dec00104 	addi	sp,sp,4
    update_seven_segment_display();

    alt_printf("Next track: %d\n", current_track);

    // Reanudar reproducción automáticamente
    play_audio();
    c4a4:	000c4201 	jmpi	c420 <play_audio>

0000c4a8 <previous_track>:
}

void previous_track(void) {
    // Pausar audio actual
    if (is_playing) {
    c4a8:	d0a44917 	ldw	r2,-28380(gp)

    // Reanudar reproducción automáticamente
    play_audio();
}

void previous_track(void) {
    c4ac:	deffff04 	addi	sp,sp,-4
    c4b0:	dfc00015 	stw	ra,0(sp)
    // Pausar audio actual
    if (is_playing) {
    c4b4:	10000126 	beq	r2,zero,c4bc <previous_track+0x14>
        pause_audio();
    c4b8:	000c4380 	call	c438 <pause_audio>
    }

    current_track--;
    c4bc:	d0a00117 	ldw	r2,-32764(gp)
    c4c0:	10bfffc4 	addi	r2,r2,-1
    c4c4:	d0a00115 	stw	r2,-32764(gp)
    if (current_track < 1) {
    c4c8:	d0a00117 	ldw	r2,-32764(gp)
    c4cc:	1000021e 	bne	r2,zero,c4d8 <previous_track+0x30>
        current_track = 10;  // Wrap around al último track
    c4d0:	00800284 	movi	r2,10
    c4d4:	d0a00115 	stw	r2,-32764(gp)
    }

    // Reset tiempo
    elapsed_ms = 0;
    c4d8:	d0244c15 	stw	zero,-28368(gp)
    elapsed_seconds = 0;
    c4dc:	d0244b15 	stw	zero,-28372(gp)
    elapsed_minutes = 0;
    c4e0:	d0244a15 	stw	zero,-28376(gp)

    update_seven_segment_display();
    c4e4:	000c2b00 	call	c2b0 <update_seven_segment_display>

    alt_printf("Previous track: %d\n", current_track);
    c4e8:	d1600117 	ldw	r5,-32764(gp)
    c4ec:	01000074 	movhi	r4,1
    c4f0:	21351104 	addi	r4,r4,-11196
    c4f4:	000ca300 	call	ca30 <alt_printf>

    // Reanudar reproducción automáticamente
    play_audio();
}
    c4f8:	dfc00017 	ldw	ra,0(sp)
    c4fc:	dec00104 	addi	sp,sp,4
    update_seven_segment_display();

    alt_printf("Previous track: %d\n", current_track);

    // Reanudar reproducción automáticamente
    play_audio();
    c500:	000c4201 	jmpi	c420 <play_audio>

0000c504 <handle_buttons>:

void handle_buttons(void) {
    volatile unsigned int * button_ptr = (unsigned int *) BUTTONS_BASE;

    // Leer estado actual de los botones
    button_state = *button_ptr;
    c504:	00800074 	movhi	r2,1
    c508:	10840804 	addi	r2,r2,4128
    c50c:	10800017 	ldw	r2,0(r2)
    // El IP de Audio de Altera típicamente no requiere limpiar interrupciones manualmente
    // pero si es necesario, sería algo como:
    // *audio_ptr = *audio_ptr;  // Leer para limpiar
}

void handle_buttons(void) {
    c510:	defffe04 	addi	sp,sp,-8
    c514:	dc000015 	stw	r16,0(sp)
    volatile unsigned int * button_ptr = (unsigned int *) BUTTONS_BASE;

    // Leer estado actual de los botones
    button_state = *button_ptr;
    c518:	d0a44815 	stw	r2,-28384(gp)

    // Detectar flancos descendentes (botón presionado)
    unsigned int button_pressed = (~button_state) & prev_button_state;
    c51c:	d4244817 	ldw	r16,-28384(gp)
    c520:	d0a44717 	ldw	r2,-28388(gp)
    // El IP de Audio de Altera típicamente no requiere limpiar interrupciones manualmente
    // pero si es necesario, sería algo como:
    // *audio_ptr = *audio_ptr;  // Leer para limpiar
}

void handle_buttons(void) {
    c524:	dfc00115 	stw	ra,4(sp)

    // Leer estado actual de los botones
    button_state = *button_ptr;

    // Detectar flancos descendentes (botón presionado)
    unsigned int button_pressed = (~button_state) & prev_button_state;
    c528:	0420303a 	nor	r16,zero,r16
    c52c:	80a0703a 	and	r16,r16,r2

    if (button_pressed & 0x1) {  // Button 0 (KEY0) - Play/Pause
    c530:	8080004c 	andi	r2,r16,1
    c534:	10000526 	beq	r2,zero,c54c <handle_buttons+0x48>
        if (is_playing) {
    c538:	d0a44917 	ldw	r2,-28380(gp)
    c53c:	10000226 	beq	r2,zero,c548 <handle_buttons+0x44>
            pause_audio();
    c540:	000c4380 	call	c438 <pause_audio>
    c544:	00000106 	br	c54c <handle_buttons+0x48>
        } else {
            play_audio();
    c548:	000c4200 	call	c420 <play_audio>
        }
    }

    if (button_pressed & 0x2) {  // Button 1 (KEY1) - Next track
    c54c:	8080008c 	andi	r2,r16,2
    c550:	10000126 	beq	r2,zero,c558 <handle_buttons+0x54>
        next_track();
    c554:	000c4480 	call	c448 <next_track>
    }

    if (button_pressed & 0x4) {  // Button 2 (KEY2) - Previous track
    c558:	8080010c 	andi	r2,r16,4
    c55c:	10000126 	beq	r2,zero,c564 <handle_buttons+0x60>
        previous_track();
    c560:	000c4a80 	call	c4a8 <previous_track>
    }

    if (button_pressed & 0x8) {  // Button 3 (KEY3) - Stop/Reset
    c564:	8400020c 	andi	r16,r16,8
    c568:	80000826 	beq	r16,zero,c58c <handle_buttons+0x88>
        pause_audio();
    c56c:	000c4380 	call	c438 <pause_audio>
        elapsed_ms = 0;
    c570:	d0244c15 	stw	zero,-28368(gp)
        elapsed_seconds = 0;
    c574:	d0244b15 	stw	zero,-28372(gp)
        elapsed_minutes = 0;
    c578:	d0244a15 	stw	zero,-28376(gp)
        update_seven_segment_display();
    c57c:	000c2b00 	call	c2b0 <update_seven_segment_display>
        alt_putstr("Playback stopped and reset\n");
    c580:	01000074 	movhi	r4,1
    c584:	21351604 	addi	r4,r4,-11176
    c588:	000cbe80 	call	cbe8 <alt_putstr>
    }

    prev_button_state = button_state;
    c58c:	d0a44817 	ldw	r2,-28384(gp)
    c590:	d0a44715 	stw	r2,-28388(gp)
}
    c594:	dfc00117 	ldw	ra,4(sp)
    c598:	dc000017 	ldw	r16,0(sp)
    c59c:	dec00204 	addi	sp,sp,8
    c5a0:	f800283a 	ret

0000c5a4 <main>:
    volatile unsigned int * timer_status_ptr = (unsigned int *) TIMER_BASE;
    volatile unsigned int * timer_control_ptr = (unsigned int *) (TIMER_BASE + 4);
    volatile unsigned int * sevenseg_ptr = (unsigned int *) SEVEN_SEGMENTS_BASE;
    volatile unsigned int * audio_ptr = (unsigned int *) AUDIO_BASE;

    alt_putstr("=== Audio Player Starting ===\n");
    c5a4:	01000074 	movhi	r4,1
void next_track(void);
void previous_track(void);
void init_audio(void);

int main()
{
    c5a8:	defffd04 	addi	sp,sp,-12
    volatile unsigned int * timer_status_ptr = (unsigned int *) TIMER_BASE;
    volatile unsigned int * timer_control_ptr = (unsigned int *) (TIMER_BASE + 4);
    volatile unsigned int * sevenseg_ptr = (unsigned int *) SEVEN_SEGMENTS_BASE;
    volatile unsigned int * audio_ptr = (unsigned int *) AUDIO_BASE;

    alt_putstr("=== Audio Player Starting ===\n");
    c5ac:	21351d04 	addi	r4,r4,-11148
void next_track(void);
void previous_track(void);
void init_audio(void);

int main()
{
    c5b0:	dfc00215 	stw	ra,8(sp)
    c5b4:	dc000115 	stw	r16,4(sp)
    volatile unsigned int * timer_status_ptr = (unsigned int *) TIMER_BASE;
    volatile unsigned int * timer_control_ptr = (unsigned int *) (TIMER_BASE + 4);
    volatile unsigned int * sevenseg_ptr = (unsigned int *) SEVEN_SEGMENTS_BASE;
    volatile unsigned int * audio_ptr = (unsigned int *) AUDIO_BASE;

    alt_putstr("=== Audio Player Starting ===\n");
    c5b8:	000cbe80 	call	cbe8 <alt_putstr>

    // Registrar manejadores de interrupciones
    alt_irq_register(TIMER_IRQ, NULL, timer_ir_handler);
    c5bc:	04000044 	movi	r16,1
    c5c0:	01800074 	movhi	r6,1
    c5c4:	8009883a 	mov	r4,r16
    c5c8:	31b0df04 	addi	r6,r6,-15492
    c5cc:	000b883a 	mov	r5,zero
    c5d0:	000c8900 	call	c890 <alt_irq_register>

    alt_irq_register(AUDIO_IRQ, NULL, audio_ir_handler);
    c5d4:	01800074 	movhi	r6,1
    c5d8:	31b06f04 	addi	r6,r6,-15940
    c5dc:	000b883a 	mov	r5,zero
    c5e0:	01000084 	movi	r4,2
    c5e4:	000c8900 	call	c890 <alt_irq_register>

    alt_putstr("Interrupt handlers registered\n");
    c5e8:	01000074 	movhi	r4,1
    c5ec:	21352504 	addi	r4,r4,-11116
    c5f0:	000cbe80 	call	cbe8 <alt_putstr>
    alt_printf("Timer IRQ: %d, Audio IRQ: %d\n", TIMER_IRQ, AUDIO_IRQ);
    c5f4:	01000074 	movhi	r4,1
    c5f8:	800b883a 	mov	r5,r16
    c5fc:	01800084 	movi	r6,2
    c600:	21352d04 	addi	r4,r4,-11084
    c604:	000ca300 	call	ca30 <alt_printf>

    // Configurar e iniciar el timer
    *timer_control_ptr = 0x7;  // START | CONT | ITO (bits 2,1,0)
    c608:	00800074 	movhi	r2,1
    c60c:	00c001c4 	movi	r3,7
    c610:	10840104 	addi	r2,r2,4100

    alt_putstr("Timer started\n");
    c614:	01000074 	movhi	r4,1

    alt_putstr("Interrupt handlers registered\n");
    alt_printf("Timer IRQ: %d, Audio IRQ: %d\n", TIMER_IRQ, AUDIO_IRQ);

    // Configurar e iniciar el timer
    *timer_control_ptr = 0x7;  // START | CONT | ITO (bits 2,1,0)
    c618:	10c00015 	stw	r3,0(r2)

    alt_putstr("Timer started\n");
    c61c:	21353504 	addi	r4,r4,-11052
    c620:	000cbe80 	call	cbe8 <alt_putstr>

    // Inicializar audio
    init_audio();
    c624:	000c3ec0 	call	c3ec <init_audio>

    // Inicializar variables
    elapsed_ms = 0;
    c628:	d0244c15 	stw	zero,-28368(gp)
    elapsed_seconds = 0;
    c62c:	d0244b15 	stw	zero,-28372(gp)
    elapsed_minutes = 0;
    c630:	d0244a15 	stw	zero,-28376(gp)
    is_playing = 0;
    c634:	d0244915 	stw	zero,-28380(gp)
    current_track = 1;  // Empezar en track 1
    c638:	d4200115 	stw	r16,-32764(gp)
    button_state = 0;
    prev_button_state = 0;

    alt_putstr("Audio Player Ready!\n");
    c63c:	01000074 	movhi	r4,1
    elapsed_ms = 0;
    elapsed_seconds = 0;
    elapsed_minutes = 0;
    is_playing = 0;
    current_track = 1;  // Empezar en track 1
    button_state = 0;
    c640:	d0244815 	stw	zero,-28384(gp)
    prev_button_state = 0;

    alt_putstr("Audio Player Ready!\n");
    c644:	21353904 	addi	r4,r4,-11036
    elapsed_seconds = 0;
    elapsed_minutes = 0;
    is_playing = 0;
    current_track = 1;  // Empezar en track 1
    button_state = 0;
    prev_button_state = 0;
    c648:	d0244715 	stw	zero,-28388(gp)

    alt_putstr("Audio Player Ready!\n");
    c64c:	000cbe80 	call	cbe8 <alt_putstr>
    alt_putstr("Controls:\n");
    c650:	01000074 	movhi	r4,1
    c654:	21353f04 	addi	r4,r4,-11012
    c658:	000cbe80 	call	cbe8 <alt_putstr>
    alt_putstr("  Button 0 (KEY0): Play/Pause\n");
    c65c:	01000074 	movhi	r4,1
    c660:	21354204 	addi	r4,r4,-11000
    c664:	000cbe80 	call	cbe8 <alt_putstr>
    alt_putstr("  Button 1 (KEY1): Next Track\n");
    c668:	01000074 	movhi	r4,1
    c66c:	21354a04 	addi	r4,r4,-10968
    c670:	000cbe80 	call	cbe8 <alt_putstr>
    alt_putstr("  Button 2 (KEY2): Previous Track\n");
    c674:	01000074 	movhi	r4,1
    c678:	21355204 	addi	r4,r4,-10936
    c67c:	000cbe80 	call	cbe8 <alt_putstr>
    alt_putstr("  Button 3 (KEY3): Stop/Reset\n");
    c680:	01000074 	movhi	r4,1
    c684:	21355b04 	addi	r4,r4,-10900
    c688:	000cbe80 	call	cbe8 <alt_putstr>

    // Display inicial
    update_seven_segment_display();
    c68c:	000c2b00 	call	c2b0 <update_seven_segment_display>
    while (1) {
        // Manejar botones (polling ya que no tienen IRQ configurado)
        handle_buttons();

        // Pequeña pausa para evitar polling excesivo
        for (volatile int i = 0; i < 10000; i++);
    c690:	0409c3c4 	movi	r16,9999
    update_seven_segment_display();

    // Loop principal del reproductor
    while (1) {
        // Manejar botones (polling ya que no tienen IRQ configurado)
        handle_buttons();
    c694:	000c5040 	call	c504 <handle_buttons>

        // Pequeña pausa para evitar polling excesivo
        for (volatile int i = 0; i < 10000; i++);
    c698:	d8000015 	stw	zero,0(sp)
    c69c:	d8800017 	ldw	r2,0(sp)
    c6a0:	80bffc16 	blt	r16,r2,c694 <_gp+0xffff6024>
    c6a4:	d8800017 	ldw	r2,0(sp)
    c6a8:	10800044 	addi	r2,r2,1
    c6ac:	d8800015 	stw	r2,0(sp)
    c6b0:	003ffa06 	br	c69c <_gp+0xffff602c>

0000c6b4 <__divsi3>:
    c6b4:	20001b16 	blt	r4,zero,c724 <__divsi3+0x70>
    c6b8:	000f883a 	mov	r7,zero
    c6bc:	28001616 	blt	r5,zero,c718 <__divsi3+0x64>
    c6c0:	200d883a 	mov	r6,r4
    c6c4:	29001a2e 	bgeu	r5,r4,c730 <__divsi3+0x7c>
    c6c8:	00800804 	movi	r2,32
    c6cc:	00c00044 	movi	r3,1
    c6d0:	00000106 	br	c6d8 <__divsi3+0x24>
    c6d4:	10000d26 	beq	r2,zero,c70c <__divsi3+0x58>
    c6d8:	294b883a 	add	r5,r5,r5
    c6dc:	10bfffc4 	addi	r2,r2,-1
    c6e0:	18c7883a 	add	r3,r3,r3
    c6e4:	293ffb36 	bltu	r5,r4,c6d4 <_gp+0xffff6064>
    c6e8:	0005883a 	mov	r2,zero
    c6ec:	18000726 	beq	r3,zero,c70c <__divsi3+0x58>
    c6f0:	0005883a 	mov	r2,zero
    c6f4:	31400236 	bltu	r6,r5,c700 <__divsi3+0x4c>
    c6f8:	314dc83a 	sub	r6,r6,r5
    c6fc:	10c4b03a 	or	r2,r2,r3
    c700:	1806d07a 	srli	r3,r3,1
    c704:	280ad07a 	srli	r5,r5,1
    c708:	183ffa1e 	bne	r3,zero,c6f4 <_gp+0xffff6084>
    c70c:	38000126 	beq	r7,zero,c714 <__divsi3+0x60>
    c710:	0085c83a 	sub	r2,zero,r2
    c714:	f800283a 	ret
    c718:	014bc83a 	sub	r5,zero,r5
    c71c:	39c0005c 	xori	r7,r7,1
    c720:	003fe706 	br	c6c0 <_gp+0xffff6050>
    c724:	0109c83a 	sub	r4,zero,r4
    c728:	01c00044 	movi	r7,1
    c72c:	003fe306 	br	c6bc <_gp+0xffff604c>
    c730:	00c00044 	movi	r3,1
    c734:	003fee06 	br	c6f0 <_gp+0xffff6080>

0000c738 <__modsi3>:
    c738:	20001716 	blt	r4,zero,c798 <__modsi3+0x60>
    c73c:	000f883a 	mov	r7,zero
    c740:	2005883a 	mov	r2,r4
    c744:	28001216 	blt	r5,zero,c790 <__modsi3+0x58>
    c748:	2900162e 	bgeu	r5,r4,c7a4 <__modsi3+0x6c>
    c74c:	01800804 	movi	r6,32
    c750:	00c00044 	movi	r3,1
    c754:	00000106 	br	c75c <__modsi3+0x24>
    c758:	30000a26 	beq	r6,zero,c784 <__modsi3+0x4c>
    c75c:	294b883a 	add	r5,r5,r5
    c760:	31bfffc4 	addi	r6,r6,-1
    c764:	18c7883a 	add	r3,r3,r3
    c768:	293ffb36 	bltu	r5,r4,c758 <_gp+0xffff60e8>
    c76c:	18000526 	beq	r3,zero,c784 <__modsi3+0x4c>
    c770:	1806d07a 	srli	r3,r3,1
    c774:	11400136 	bltu	r2,r5,c77c <__modsi3+0x44>
    c778:	1145c83a 	sub	r2,r2,r5
    c77c:	280ad07a 	srli	r5,r5,1
    c780:	183ffb1e 	bne	r3,zero,c770 <_gp+0xffff6100>
    c784:	38000126 	beq	r7,zero,c78c <__modsi3+0x54>
    c788:	0085c83a 	sub	r2,zero,r2
    c78c:	f800283a 	ret
    c790:	014bc83a 	sub	r5,zero,r5
    c794:	003fec06 	br	c748 <_gp+0xffff60d8>
    c798:	0109c83a 	sub	r4,zero,r4
    c79c:	01c00044 	movi	r7,1
    c7a0:	003fe706 	br	c740 <_gp+0xffff60d0>
    c7a4:	00c00044 	movi	r3,1
    c7a8:	003ff106 	br	c770 <_gp+0xffff6100>

0000c7ac <__udivsi3>:
    c7ac:	200d883a 	mov	r6,r4
    c7b0:	2900152e 	bgeu	r5,r4,c808 <__udivsi3+0x5c>
    c7b4:	28001416 	blt	r5,zero,c808 <__udivsi3+0x5c>
    c7b8:	00800804 	movi	r2,32
    c7bc:	00c00044 	movi	r3,1
    c7c0:	00000206 	br	c7cc <__udivsi3+0x20>
    c7c4:	10000e26 	beq	r2,zero,c800 <__udivsi3+0x54>
    c7c8:	28000516 	blt	r5,zero,c7e0 <__udivsi3+0x34>
    c7cc:	294b883a 	add	r5,r5,r5
    c7d0:	10bfffc4 	addi	r2,r2,-1
    c7d4:	18c7883a 	add	r3,r3,r3
    c7d8:	293ffa36 	bltu	r5,r4,c7c4 <_gp+0xffff6154>
    c7dc:	18000826 	beq	r3,zero,c800 <__udivsi3+0x54>
    c7e0:	0005883a 	mov	r2,zero
    c7e4:	31400236 	bltu	r6,r5,c7f0 <__udivsi3+0x44>
    c7e8:	314dc83a 	sub	r6,r6,r5
    c7ec:	10c4b03a 	or	r2,r2,r3
    c7f0:	1806d07a 	srli	r3,r3,1
    c7f4:	280ad07a 	srli	r5,r5,1
    c7f8:	183ffa1e 	bne	r3,zero,c7e4 <_gp+0xffff6174>
    c7fc:	f800283a 	ret
    c800:	0005883a 	mov	r2,zero
    c804:	f800283a 	ret
    c808:	00c00044 	movi	r3,1
    c80c:	003ff406 	br	c7e0 <_gp+0xffff6170>

0000c810 <__umodsi3>:
    c810:	2005883a 	mov	r2,r4
    c814:	2900122e 	bgeu	r5,r4,c860 <__umodsi3+0x50>
    c818:	28001116 	blt	r5,zero,c860 <__umodsi3+0x50>
    c81c:	01800804 	movi	r6,32
    c820:	00c00044 	movi	r3,1
    c824:	00000206 	br	c830 <__umodsi3+0x20>
    c828:	30000c26 	beq	r6,zero,c85c <__umodsi3+0x4c>
    c82c:	28000516 	blt	r5,zero,c844 <__umodsi3+0x34>
    c830:	294b883a 	add	r5,r5,r5
    c834:	31bfffc4 	addi	r6,r6,-1
    c838:	18c7883a 	add	r3,r3,r3
    c83c:	293ffa36 	bltu	r5,r4,c828 <_gp+0xffff61b8>
    c840:	18000626 	beq	r3,zero,c85c <__umodsi3+0x4c>
    c844:	1806d07a 	srli	r3,r3,1
    c848:	11400136 	bltu	r2,r5,c850 <__umodsi3+0x40>
    c84c:	1145c83a 	sub	r2,r2,r5
    c850:	280ad07a 	srli	r5,r5,1
    c854:	183ffb1e 	bne	r3,zero,c844 <_gp+0xffff61d4>
    c858:	f800283a 	ret
    c85c:	f800283a 	ret
    c860:	00c00044 	movi	r3,1
    c864:	003ff706 	br	c844 <_gp+0xffff61d4>

0000c868 <__mulsi3>:
    c868:	0005883a 	mov	r2,zero
    c86c:	20000726 	beq	r4,zero,c88c <__mulsi3+0x24>
    c870:	20c0004c 	andi	r3,r4,1
    c874:	2008d07a 	srli	r4,r4,1
    c878:	18000126 	beq	r3,zero,c880 <__mulsi3+0x18>
    c87c:	1145883a 	add	r2,r2,r5
    c880:	294b883a 	add	r5,r5,r5
    c884:	203ffa1e 	bne	r4,zero,c870 <_gp+0xffff6200>
    c888:	f800283a 	ret
    c88c:	f800283a 	ret

0000c890 <alt_irq_register>:
                      alt_isr_func handler)
{
  int rc = -EINVAL;  
  alt_irq_context status;

  if (id < ALT_NIRQ)
    c890:	008007c4 	movi	r2,31
    c894:	11002136 	bltu	r2,r4,c91c <alt_irq_register+0x8c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
    c898:	000f303a 	rdctl	r7,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
    c89c:	00ffff84 	movi	r3,-2
    c8a0:	38c4703a 	and	r2,r7,r3
    c8a4:	1001703a 	wrctl	status,r2
     * state.
     */

    status = alt_irq_disable_all ();

    alt_irq[id].handler = handler;
    c8a8:	200490fa 	slli	r2,r4,3
    c8ac:	02000074 	movhi	r8,1
    c8b0:	423df104 	addi	r8,r8,-2108
    c8b4:	4085883a 	add	r2,r8,r2
    c8b8:	11800015 	stw	r6,0(r2)
    alt_irq[id].context = context;
    c8bc:	11400115 	stw	r5,4(r2)
    c8c0:	00800044 	movi	r2,1

    rc = (handler) ? alt_irq_enable (id): alt_irq_disable (id);
    c8c4:	30000726 	beq	r6,zero,c8e4 <alt_irq_register+0x54>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
    c8c8:	000b303a 	rdctl	r5,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
    c8cc:	28c6703a 	and	r3,r5,r3
    c8d0:	1801703a 	wrctl	status,r3
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();

  alt_irq_active |= (1 << id);
    c8d4:	d0e44d17 	ldw	r3,-28364(gp)
    c8d8:	1104983a 	sll	r2,r2,r4
    c8dc:	10c4b03a 	or	r2,r2,r3
    c8e0:	00000706 	br	c900 <alt_irq_register+0x70>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
    c8e4:	000b303a 	rdctl	r5,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
    c8e8:	28c6703a 	and	r3,r5,r3
    c8ec:	1801703a 	wrctl	status,r3
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();

  alt_irq_active &= ~(1 << id);
    c8f0:	1104983a 	sll	r2,r2,r4
    c8f4:	d0e44d17 	ldw	r3,-28364(gp)
    c8f8:	0084303a 	nor	r2,zero,r2
    c8fc:	10c4703a 	and	r2,r2,r3
    c900:	d0a44d15 	stw	r2,-28364(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
    c904:	d0a44d17 	ldw	r2,-28364(gp)
    c908:	100170fa 	wrctl	ienable,r2
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
    c90c:	2801703a 	wrctl	status,r5
    c910:	3801703a 	wrctl	status,r7
    c914:	0005883a 	mov	r2,zero
    c918:	f800283a 	ret
 
int alt_irq_register (alt_u32 id, 
                      void* context, 
                      alt_isr_func handler)
{
  int rc = -EINVAL;  
    c91c:	00bffa84 	movi	r2,-22
    rc = (handler) ? alt_irq_enable (id): alt_irq_disable (id);

    alt_irq_enable_all(status);
  }
  return rc; 
}
    c920:	f800283a 	ret

0000c924 <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
    c924:	deffff04 	addi	sp,sp,-4
    c928:	01000074 	movhi	r4,1
    c92c:	01400074 	movhi	r5,1
    c930:	dfc00015 	stw	ra,0(sp)
    c934:	21356c04 	addi	r4,r4,-10832
    c938:	2979a704 	addi	r5,r5,-6500

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
    c93c:	2140061e 	bne	r4,r5,c958 <alt_load+0x34>
    c940:	01000074 	movhi	r4,1
    c944:	01400074 	movhi	r5,1
    c948:	21300804 	addi	r4,r4,-16352
    c94c:	29700804 	addi	r5,r5,-16352
    c950:	2140121e 	bne	r4,r5,c99c <alt_load+0x78>
    c954:	00000b06 	br	c984 <alt_load+0x60>
    c958:	00c00074 	movhi	r3,1
    c95c:	18f9a704 	addi	r3,r3,-6500
    c960:	1907c83a 	sub	r3,r3,r4
    c964:	0005883a 	mov	r2,zero
  {
    while( to != end )
    c968:	10fff526 	beq	r2,r3,c940 <_gp+0xffff62d0>
    {
      *to++ = *from++;
    c96c:	114f883a 	add	r7,r2,r5
    c970:	39c00017 	ldw	r7,0(r7)
    c974:	110d883a 	add	r6,r2,r4
    c978:	10800104 	addi	r2,r2,4
    c97c:	31c00015 	stw	r7,0(r6)
    c980:	003ff906 	br	c968 <_gp+0xffff62f8>
    c984:	01000074 	movhi	r4,1
    c988:	01400074 	movhi	r5,1
    c98c:	2134fe04 	addi	r4,r4,-11272
    c990:	2974fe04 	addi	r5,r5,-11272

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
    c994:	2140101e 	bne	r4,r5,c9d8 <alt_load+0xb4>
    c998:	00000b06 	br	c9c8 <alt_load+0xa4>
    c99c:	00c00074 	movhi	r3,1
    c9a0:	18f06004 	addi	r3,r3,-16000
    c9a4:	1907c83a 	sub	r3,r3,r4
    c9a8:	0005883a 	mov	r2,zero
  {
    while( to != end )
    c9ac:	10fff526 	beq	r2,r3,c984 <_gp+0xffff6314>
    {
      *to++ = *from++;
    c9b0:	114f883a 	add	r7,r2,r5
    c9b4:	39c00017 	ldw	r7,0(r7)
    c9b8:	110d883a 	add	r6,r2,r4
    c9bc:	10800104 	addi	r2,r2,4
    c9c0:	31c00015 	stw	r7,0(r6)
    c9c4:	003ff906 	br	c9ac <_gp+0xffff633c>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
    c9c8:	000d0340 	call	d034 <alt_dcache_flush_all>
  alt_icache_flush_all();
}
    c9cc:	dfc00017 	ldw	ra,0(sp)
    c9d0:	dec00104 	addi	sp,sp,4
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
  alt_icache_flush_all();
    c9d4:	000d0ac1 	jmpi	d0ac <alt_icache_flush_all>
    c9d8:	00c00074 	movhi	r3,1
    c9dc:	18f56c04 	addi	r3,r3,-10832
    c9e0:	1907c83a 	sub	r3,r3,r4

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
    c9e4:	0005883a 	mov	r2,zero
  {
    while( to != end )
    c9e8:	18bff726 	beq	r3,r2,c9c8 <_gp+0xffff6358>
    {
      *to++ = *from++;
    c9ec:	114f883a 	add	r7,r2,r5
    c9f0:	39c00017 	ldw	r7,0(r7)
    c9f4:	110d883a 	add	r6,r2,r4
    c9f8:	10800104 	addi	r2,r2,4
    c9fc:	31c00015 	stw	r7,0(r6)
    ca00:	003ff906 	br	c9e8 <_gp+0xffff6378>

0000ca04 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
    ca04:	deffff04 	addi	sp,sp,-4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
    ca08:	0009883a 	mov	r4,zero
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
    ca0c:	dfc00015 	stw	ra,0(sp)
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
    ca10:	000cc200 	call	cc20 <alt_irq_init>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
    ca14:	000cc400 	call	cc40 <alt_sys_init>
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
    ca18:	d1a44e17 	ldw	r6,-28360(gp)
    ca1c:	d1644f17 	ldw	r5,-28356(gp)
    ca20:	d1245017 	ldw	r4,-28352(gp)
  close(STDOUT_FILENO);
  exit (result);
#endif

  ALT_LOG_PRINT_BOOT("[alt_main.c] After main - we should not be here?.\r\n");
}
    ca24:	dfc00017 	ldw	ra,0(sp)
    ca28:	dec00104 	addi	sp,sp,4
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
    ca2c:	000c5a41 	jmpi	c5a4 <main>

0000ca30 <alt_printf>:
/* 
 * ALT printf function 
 */
void 
alt_printf(const char* fmt, ... )
{
    ca30:	defff204 	addi	sp,sp,-56
    ca34:	2005883a 	mov	r2,r4
    ca38:	dfc00a15 	stw	ra,40(sp)
    ca3c:	df000915 	stw	fp,36(sp)
    ca40:	ddc00815 	stw	r23,32(sp)
    ca44:	dd800715 	stw	r22,28(sp)
    ca48:	dd400615 	stw	r21,24(sp)
    ca4c:	dd000515 	stw	r20,20(sp)
    ca50:	dcc00415 	stw	r19,16(sp)
    ca54:	dc800315 	stw	r18,12(sp)
    ca58:	dc400215 	stw	r17,8(sp)
    ca5c:	dc000115 	stw	r16,4(sp)
    ca60:	d9400b15 	stw	r5,44(sp)
    ca64:	d9800c15 	stw	r6,48(sp)
    ca68:	d9c00d15 	stw	r7,52(sp)
    w = fmt;
    while ((c = *w++) != 0)
    {
        /* If not a format escape character, just print  */
        /* character.  Otherwise, process format string. */
        if (c != '%')
    ca6c:	04000944 	movi	r16,37
 */
void 
alt_printf(const char* fmt, ... )
{
	va_list args;
	va_start(args, fmt);
    ca70:	dd400b04 	addi	r21,sp,44
                if (c == '%')
                {
                    /* Process "%" escape sequence. */
                    alt_putchar(c);
                } 
                else if (c == 'c')
    ca74:	048018c4 	movi	r18,99
                {
                    int v = va_arg(args, int);
                    alt_putchar(v);
                }
                else if (c == 'x')
    ca78:	04c01e04 	movi	r19,120
                        else
                            c = 'a' + digit - 10;
                        alt_putchar(c);
                    }
                }
                else if (c == 's')
    ca7c:	05001cc4 	movi	r20,115
    const char *w;
    char c;

    /* Process format string. */
    w = fmt;
    while ((c = *w++) != 0)
    ca80:	11000007 	ldb	r4,0(r2)
    ca84:	20003a26 	beq	r4,zero,cb70 <alt_printf+0x140>
    {
        /* If not a format escape character, just print  */
        /* character.  Otherwise, process format string. */
        if (c != '%')
    ca88:	24000226 	beq	r4,r16,ca94 <alt_printf+0x64>
    const char *w;
    char c;

    /* Process format string. */
    w = fmt;
    while ((c = *w++) != 0)
    ca8c:	14400044 	addi	r17,r2,1
    ca90:	00001406 	br	cae4 <alt_printf+0xb4>
        }
        else
        {
            /* Get format character.  If none     */
            /* available, processing is complete. */
            if ((c = *w++) != 0)
    ca94:	14400084 	addi	r17,r2,2
    ca98:	10800047 	ldb	r2,1(r2)
    ca9c:	10003426 	beq	r2,zero,cb70 <alt_printf+0x140>
            {
                if (c == '%')
    caa0:	1400021e 	bne	r2,r16,caac <alt_printf+0x7c>
                {
                    /* Process "%" escape sequence. */
                    alt_putchar(c);
    caa4:	8009883a 	mov	r4,r16
    caa8:	00000e06 	br	cae4 <alt_printf+0xb4>
                } 
                else if (c == 'c')
    caac:	1480051e 	bne	r2,r18,cac4 <alt_printf+0x94>
                {
                    int v = va_arg(args, int);
                    alt_putchar(v);
    cab0:	a9000017 	ldw	r4,0(r21)
                    /* Process "%" escape sequence. */
                    alt_putchar(c);
                } 
                else if (c == 'c')
                {
                    int v = va_arg(args, int);
    cab4:	ad800104 	addi	r22,r21,4
    cab8:	b02b883a 	mov	r21,r22
                    alt_putchar(v);
    cabc:	000cba00 	call	cba0 <alt_putchar>
    cac0:	00002906 	br	cb68 <alt_printf+0x138>
                }
                else if (c == 'x')
    cac4:	14c0201e 	bne	r2,r19,cb48 <alt_printf+0x118>
                {
                    /* Process hexadecimal number format. */
                    unsigned long v = va_arg(args, unsigned long);
    cac8:	adc00017 	ldw	r23,0(r21)
    cacc:	ad400104 	addi	r21,r21,4
                    unsigned long digit;
                    int digit_shift;

                    /* If the number value is zero, just print and continue. */
                    if (v == 0)
    cad0:	b8000326 	beq	r23,zero,cae0 <alt_printf+0xb0>
    cad4:	05800704 	movi	r22,28
                        continue;
                    }

                    /* Find first non-zero digit. */
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
    cad8:	00c003c4 	movi	r3,15
    cadc:	00000306 	br	caec <alt_printf+0xbc>
                    int digit_shift;

                    /* If the number value is zero, just print and continue. */
                    if (v == 0)
                    {
                        alt_putchar('0');
    cae0:	01000c04 	movi	r4,48
    cae4:	000cba00 	call	cba0 <alt_putchar>
                        continue;
    cae8:	00001f06 	br	cb68 <alt_printf+0x138>
                    }

                    /* Find first non-zero digit. */
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
    caec:	1d84983a 	sll	r2,r3,r22
    caf0:	15c4703a 	and	r2,r2,r23
    caf4:	1000021e 	bne	r2,zero,cb00 <alt_printf+0xd0>
                        digit_shift -= 4;
    caf8:	b5bfff04 	addi	r22,r22,-4
    cafc:	003ffb06 	br	caec <_gp+0xffff647c>

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
                    {
                        digit = (v & (0xF << digit_shift)) >> digit_shift;
    cb00:	070003c4 	movi	fp,15
                        if (digit <= 9)
    cb04:	00c00244 	movi	r3,9
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
                        digit_shift -= 4;

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
    cb08:	b0001716 	blt	r22,zero,cb68 <alt_printf+0x138>
                    {
                        digit = (v & (0xF << digit_shift)) >> digit_shift;
    cb0c:	e588983a 	sll	r4,fp,r22
    cb10:	25c8703a 	and	r4,r4,r23
    cb14:	2588d83a 	srl	r4,r4,r22
                        if (digit <= 9)
    cb18:	19000236 	bltu	r3,r4,cb24 <alt_printf+0xf4>
                            c = '0' + digit;
    cb1c:	21000c04 	addi	r4,r4,48
    cb20:	00000106 	br	cb28 <alt_printf+0xf8>
                        else
                            c = 'a' + digit - 10;
    cb24:	210015c4 	addi	r4,r4,87
                        alt_putchar(c);
    cb28:	21003fcc 	andi	r4,r4,255
    cb2c:	2100201c 	xori	r4,r4,128
    cb30:	213fe004 	addi	r4,r4,-128
    cb34:	d8c00015 	stw	r3,0(sp)
    cb38:	000cba00 	call	cba0 <alt_putchar>
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
                        digit_shift -= 4;

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
    cb3c:	b5bfff04 	addi	r22,r22,-4
    cb40:	d8c00017 	ldw	r3,0(sp)
    cb44:	003ff006 	br	cb08 <_gp+0xffff6498>
                        else
                            c = 'a' + digit - 10;
                        alt_putchar(c);
                    }
                }
                else if (c == 's')
    cb48:	1500071e 	bne	r2,r20,cb68 <alt_printf+0x138>
                {
                    /* Process string format. */
                    char *s = va_arg(args, char *);
    cb4c:	ad800017 	ldw	r22,0(r21)
    cb50:	ad400104 	addi	r21,r21,4

                    while(*s)
    cb54:	b1000007 	ldb	r4,0(r22)
    cb58:	20000326 	beq	r4,zero,cb68 <alt_printf+0x138>
                      alt_putchar(*s++);
    cb5c:	b5800044 	addi	r22,r22,1
    cb60:	000cba00 	call	cba0 <alt_putchar>
    cb64:	003ffb06 	br	cb54 <_gp+0xffff64e4>
                    /* Process "%" escape sequence. */
                    alt_putchar(c);
                } 
                else if (c == 'c')
                {
                    int v = va_arg(args, int);
    cb68:	8805883a 	mov	r2,r17
    cb6c:	003fc406 	br	ca80 <_gp+0xffff6410>
        }
    }
#ifdef ALT_SEMIHOSTING
    alt_putbufflush();
#endif
}
    cb70:	dfc00a17 	ldw	ra,40(sp)
    cb74:	df000917 	ldw	fp,36(sp)
    cb78:	ddc00817 	ldw	r23,32(sp)
    cb7c:	dd800717 	ldw	r22,28(sp)
    cb80:	dd400617 	ldw	r21,24(sp)
    cb84:	dd000517 	ldw	r20,20(sp)
    cb88:	dcc00417 	ldw	r19,16(sp)
    cb8c:	dc800317 	ldw	r18,12(sp)
    cb90:	dc400217 	ldw	r17,8(sp)
    cb94:	dc000117 	ldw	r16,4(sp)
    cb98:	dec00e04 	addi	sp,sp,56
    cb9c:	f800283a 	ret

0000cba0 <alt_putchar>:
 * Uses the ALT_DRIVER_WRITE() macro to call directly to driver if available.
 * Otherwise, uses newlib provided putchar() routine.
 */
int 
alt_putchar(int c)
{
    cba0:	defffd04 	addi	sp,sp,-12
    cba4:	dc000115 	stw	r16,4(sp)
	char        c1 = (char)(c & 0xff);
    return write(STDOUT_FILENO,&c1,1);
#else
#ifdef ALT_USE_DIRECT_DRIVERS
    ALT_DRIVER_WRITE_EXTERNS(ALT_STDOUT_DEV);
    char        c1 = (char)(c & 0xff);
    cba8:	d9000005 	stb	r4,0(sp)
 * Uses the ALT_DRIVER_WRITE() macro to call directly to driver if available.
 * Otherwise, uses newlib provided putchar() routine.
 */
int 
alt_putchar(int c)
{
    cbac:	2021883a 	mov	r16,r4
#else
#ifdef ALT_USE_DIRECT_DRIVERS
    ALT_DRIVER_WRITE_EXTERNS(ALT_STDOUT_DEV);
    char        c1 = (char)(c & 0xff);

    if (ALT_DRIVER_WRITE(ALT_STDOUT_DEV, &c1, 1, 0) == -1) {
    cbb0:	01000074 	movhi	r4,1
    cbb4:	000f883a 	mov	r7,zero
    cbb8:	01800044 	movi	r6,1
    cbbc:	d80b883a 	mov	r5,sp
    cbc0:	21357804 	addi	r4,r4,-10784
 * Uses the ALT_DRIVER_WRITE() macro to call directly to driver if available.
 * Otherwise, uses newlib provided putchar() routine.
 */
int 
alt_putchar(int c)
{
    cbc4:	dfc00215 	stw	ra,8(sp)
#else
#ifdef ALT_USE_DIRECT_DRIVERS
    ALT_DRIVER_WRITE_EXTERNS(ALT_STDOUT_DEV);
    char        c1 = (char)(c & 0xff);

    if (ALT_DRIVER_WRITE(ALT_STDOUT_DEV, &c1, 1, 0) == -1) {
    cbc8:	000ce440 	call	ce44 <altera_avalon_jtag_uart_write>
    cbcc:	00ffffc4 	movi	r3,-1
    cbd0:	10c00126 	beq	r2,r3,cbd8 <alt_putchar+0x38>
        return -1;
    }
    return c;
    cbd4:	8005883a 	mov	r2,r16
#else
    return putchar(c);
#endif
#endif
}
    cbd8:	dfc00217 	ldw	ra,8(sp)
    cbdc:	dc000117 	ldw	r16,4(sp)
    cbe0:	dec00304 	addi	sp,sp,12
    cbe4:	f800283a 	ret

0000cbe8 <alt_putstr>:
 * Uses the ALT_DRIVER_WRITE() macro to call directly to driver if available.
 * Otherwise, uses newlib provided fputs() routine.
 */
int 
alt_putstr(const char* str)
{
    cbe8:	defffe04 	addi	sp,sp,-8
    cbec:	dc000015 	stw	r16,0(sp)
    cbf0:	dfc00115 	stw	ra,4(sp)
    cbf4:	2021883a 	mov	r16,r4
#ifdef ALT_SEMIHOSTING
    return write(STDOUT_FILENO,str,strlen(str));
#else
#ifdef ALT_USE_DIRECT_DRIVERS
    ALT_DRIVER_WRITE_EXTERNS(ALT_STDOUT_DEV);
    return ALT_DRIVER_WRITE(ALT_STDOUT_DEV, str, strlen(str), 0);
    cbf8:	000d3600 	call	d360 <strlen>
    cbfc:	01000074 	movhi	r4,1
    cc00:	000f883a 	mov	r7,zero
    cc04:	100d883a 	mov	r6,r2
    cc08:	800b883a 	mov	r5,r16
    cc0c:	21357804 	addi	r4,r4,-10784
#else
    return fputs(str, stdout);
#endif
#endif
}
    cc10:	dfc00117 	ldw	ra,4(sp)
    cc14:	dc000017 	ldw	r16,0(sp)
    cc18:	dec00204 	addi	sp,sp,8
#ifdef ALT_SEMIHOSTING
    return write(STDOUT_FILENO,str,strlen(str));
#else
#ifdef ALT_USE_DIRECT_DRIVERS
    ALT_DRIVER_WRITE_EXTERNS(ALT_STDOUT_DEV);
    return ALT_DRIVER_WRITE(ALT_STDOUT_DEV, str, strlen(str), 0);
    cc1c:	000ce441 	jmpi	ce44 <altera_avalon_jtag_uart_write>

0000cc20 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
    cc20:	deffff04 	addi	sp,sp,-4
    cc24:	dfc00015 	stw	ra,0(sp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( NIOS, NIOS);
    cc28:	000d19c0 	call	d19c <altera_nios2_gen2_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts (void)
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
    cc2c:	00800044 	movi	r2,1
    cc30:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
    cc34:	dfc00017 	ldw	ra,0(sp)
    cc38:	dec00104 	addi	sp,sp,4
    cc3c:	f800283a 	ret

0000cc40 <alt_sys_init>:
 */

void alt_sys_init( void )
{
    ALTERA_AVALON_TIMER_INIT ( TIMER, TIMER);
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART, JTAG_UART);
    cc40:	01000074 	movhi	r4,1
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
    cc44:	deffff04 	addi	sp,sp,-4
    ALTERA_AVALON_TIMER_INIT ( TIMER, TIMER);
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART, JTAG_UART);
    cc48:	000d883a 	mov	r6,zero
    cc4c:	000b883a 	mov	r5,zero
    cc50:	21357804 	addi	r4,r4,-10784
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
    cc54:	dfc00015 	stw	ra,0(sp)
    ALTERA_AVALON_TIMER_INIT ( TIMER, TIMER);
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART, JTAG_UART);
    cc58:	000cda40 	call	cda4 <altera_avalon_jtag_uart_init>

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
    cc5c:	01000074 	movhi	r4,1
    cc60:	d1600404 	addi	r5,gp,-32752
    cc64:	21356c04 	addi	r4,r4,-10832
    ALTERA_UP_AVALON_AUDIO_INIT ( AUDIO, AUDIO);
}
    cc68:	dfc00017 	ldw	ra,0(sp)
    cc6c:	dec00104 	addi	sp,sp,4
    cc70:	000d0401 	jmpi	d040 <alt_dev_llist_insert>

0000cc74 <altera_avalon_jtag_uart_timeout>:
static alt_u32 
altera_avalon_jtag_uart_timeout(void* context) 
{
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state *) context;

  unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base);
    cc74:	20800017 	ldw	r2,0(r4)
    cc78:	10800104 	addi	r2,r2,4
    cc7c:	10c00037 	ldwio	r3,0(r2)

  if (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK)
    cc80:	18c1000c 	andi	r3,r3,1024
    cc84:	18000526 	beq	r3,zero,cc9c <altera_avalon_jtag_uart_timeout+0x28>
  {
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable | ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK);
    cc88:	20c00817 	ldw	r3,32(r4)
    cc8c:	18c10014 	ori	r3,r3,1024
    cc90:	10c00035 	stwio	r3,0(r2)
    sp->host_inactive = 0;
    cc94:	20000915 	stw	zero,36(r4)
    cc98:	00000606 	br	ccb4 <altera_avalon_jtag_uart_timeout+0x40>
  }
  else if (sp->host_inactive < INT_MAX - 2) {
    cc9c:	20800917 	ldw	r2,36(r4)
    cca0:	00e00034 	movhi	r3,32768
    cca4:	18ffff04 	addi	r3,r3,-4
    cca8:	18800236 	bltu	r3,r2,ccb4 <altera_avalon_jtag_uart_timeout+0x40>
    sp->host_inactive++;
    ccac:	10800044 	addi	r2,r2,1
    ccb0:	20800915 	stw	r2,36(r4)
      ALT_FLAG_POST (sp->events, ALT_JTAG_UART_TIMEOUT, OS_FLAG_SET);
    }
  }

  return alt_ticks_per_second();
}
    ccb4:	d0a45217 	ldw	r2,-28344(gp)
    ccb8:	f800283a 	ret

0000ccbc <altera_avalon_jtag_uart_irq>:
#else
static void altera_avalon_jtag_uart_irq(void* context, alt_u32 id)
#endif
{
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state*) context;
  unsigned int base = sp->base;
    ccbc:	21c00017 	ldw	r7,0(r4)
      if (data & ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_MSK)
      {
        /* If there is still data available here then the buffer is full 
         * so turn off receive interrupts until some space becomes available.
         */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
    ccc0:	027fff84 	movi	r9,-2
      }

      if (space > 0)
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
    ccc4:	023fff44 	movi	r8,-3
  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ISR_FUNCTION(base, sp);

  for ( ; ; )
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
    ccc8:	39800104 	addi	r6,r7,4
    cccc:	30800037 	ldwio	r2,0(r6)

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
    ccd0:	10c0c00c 	andi	r3,r2,768
    ccd4:	18003226 	beq	r3,zero,cda0 <altera_avalon_jtag_uart_irq+0xe4>
      break;

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK)
    ccd8:	10c0400c 	andi	r3,r2,256
    ccdc:	18001826 	beq	r3,zero,cd40 <altera_avalon_jtag_uart_irq+0x84>
    cce0:	00c00074 	movhi	r3,1
      for ( ; ; )
      {
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
    cce4:	21400a17 	ldw	r5,40(r4)
        if (next == sp->rx_out)
    cce8:	22800b17 	ldw	r10,44(r4)
    ccec:	29400044 	addi	r5,r5,1
    ccf0:	2941ffcc 	andi	r5,r5,2047
    ccf4:	2a800b26 	beq	r5,r10,cd24 <altera_avalon_jtag_uart_irq+0x68>
          break;

        /* Try to remove a character from the FIFO and find out whether there
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
    ccf8:	38c00037 	ldwio	r3,0(r7)
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
    ccfc:	1960000c 	andi	r5,r3,32768
    cd00:	28000826 	beq	r5,zero,cd24 <altera_avalon_jtag_uart_irq+0x68>
          break;

        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
    cd04:	21400a17 	ldw	r5,40(r4)
    cd08:	214b883a 	add	r5,r4,r5
    cd0c:	28c00e05 	stb	r3,56(r5)
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
    cd10:	21400a17 	ldw	r5,40(r4)
    cd14:	29400044 	addi	r5,r5,1
    cd18:	2941ffcc 	andi	r5,r5,2047
    cd1c:	21400a15 	stw	r5,40(r4)
    cd20:	003ff006 	br	cce4 <_gp+0xffff6674>

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }

      if (data & ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_MSK)
    cd24:	18ffffec 	andhi	r3,r3,65535
    cd28:	18000526 	beq	r3,zero,cd40 <altera_avalon_jtag_uart_irq+0x84>
      {
        /* If there is still data available here then the buffer is full 
         * so turn off receive interrupts until some space becomes available.
         */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
    cd2c:	20c00817 	ldw	r3,32(r4)
    cd30:	1a46703a 	and	r3,r3,r9
    cd34:	20c00815 	stw	r3,32(r4)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(base, sp->irq_enable);
    cd38:	30c00035 	stwio	r3,0(r6)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
    cd3c:	30c00037 	ldwio	r3,0(r6)
      }
    }

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
    cd40:	10c0800c 	andi	r3,r2,512
    cd44:	183fe126 	beq	r3,zero,cccc <_gp+0xffff665c>
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
    cd48:	1004d43a 	srli	r2,r2,16

      while (space > 0 && sp->tx_out != sp->tx_in)
    cd4c:	103fdf26 	beq	r2,zero,cccc <_gp+0xffff665c>
    cd50:	21400d17 	ldw	r5,52(r4)
    cd54:	20c00c17 	ldw	r3,48(r4)
    cd58:	28c00a26 	beq	r5,r3,cd84 <altera_avalon_jtag_uart_irq+0xc8>
      {
        IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, sp->tx_buf[sp->tx_out]);
    cd5c:	20c00d17 	ldw	r3,52(r4)
    cd60:	20c7883a 	add	r3,r4,r3
    cd64:	18c20e07 	ldb	r3,2104(r3)
    cd68:	38c00035 	stwio	r3,0(r7)

        sp->tx_out = (sp->tx_out + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
    cd6c:	20c00d17 	ldw	r3,52(r4)

        /* Post an event to notify jtag_uart_write that a character has been written */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
    cd70:	10bfffc4 	addi	r2,r2,-1

      while (space > 0 && sp->tx_out != sp->tx_in)
      {
        IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, sp->tx_buf[sp->tx_out]);

        sp->tx_out = (sp->tx_out + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
    cd74:	18c00044 	addi	r3,r3,1
    cd78:	18c1ffcc 	andi	r3,r3,2047
    cd7c:	20c00d15 	stw	r3,52(r4)
    cd80:	003ff206 	br	cd4c <_gp+0xffff66dc>
      }

      if (space > 0)
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
    cd84:	20800817 	ldw	r2,32(r4)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
    cd88:	20c00017 	ldw	r3,0(r4)
      }

      if (space > 0)
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
    cd8c:	1204703a 	and	r2,r2,r8
    cd90:	20800815 	stw	r2,32(r4)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
    cd94:	18800135 	stwio	r2,4(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
    cd98:	30800037 	ldwio	r2,0(r6)
    cd9c:	003fcb06 	br	cccc <_gp+0xffff665c>
    cda0:	f800283a 	ret

0000cda4 <altera_avalon_jtag_uart_init>:
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
    cda4:	defffe04 	addi	sp,sp,-8
    cda8:	dc000015 	stw	r16,0(sp)
    cdac:	2021883a 	mov	r16,r4
  ALT_SEM_CREATE(&sp->write_lock, 1);

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;

  IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable); 
    cdb0:	80c00017 	ldw	r3,0(r16)
  ALT_FLAG_CREATE(&sp->events, 0);
  ALT_SEM_CREATE(&sp->read_lock, 1);
  ALT_SEM_CREATE(&sp->write_lock, 1);

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
    cdb4:	00800044 	movi	r2,1
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
    cdb8:	dfc00115 	stw	ra,4(sp)
    cdbc:	3009883a 	mov	r4,r6
  ALT_FLAG_CREATE(&sp->events, 0);
  ALT_SEM_CREATE(&sp->read_lock, 1);
  ALT_SEM_CREATE(&sp->write_lock, 1);

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
    cdc0:	80800815 	stw	r2,32(r16)

  IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable); 
    cdc4:	18800135 	stwio	r2,4(r3)
  /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, altera_avalon_jtag_uart_irq, 
                      sp, NULL);
#else
  alt_irq_register(irq, sp, altera_avalon_jtag_uart_irq);
    cdc8:	01800074 	movhi	r6,1
    cdcc:	31b32f04 	addi	r6,r6,-13124
    cdd0:	800b883a 	mov	r5,r16
    cdd4:	000c8900 	call	c890 <alt_irq_register>
#endif  

  /* Register an alarm to go off every second to check for presence of host */
  sp->host_inactive = 0;

  if (alt_alarm_start(&sp->alarm, alt_ticks_per_second(), 
    cdd8:	d1645217 	ldw	r5,-28344(gp)
    cddc:	01800074 	movhi	r6,1
#else
  alt_irq_register(irq, sp, altera_avalon_jtag_uart_irq);
#endif  

  /* Register an alarm to go off every second to check for presence of host */
  sp->host_inactive = 0;
    cde0:	80000915 	stw	zero,36(r16)

  if (alt_alarm_start(&sp->alarm, alt_ticks_per_second(), 
    cde4:	800f883a 	mov	r7,r16
    cde8:	31b31d04 	addi	r6,r6,-13196
    cdec:	81000204 	addi	r4,r16,8
    cdf0:	000cfb40 	call	cfb4 <alt_alarm_start>
    cdf4:	1000030e 	bge	r2,zero,ce04 <altera_avalon_jtag_uart_init+0x60>
    &altera_avalon_jtag_uart_timeout, sp) < 0)
  {
    /* If we can't set the alarm then record "don't know if host present" 
     * and behave as though the host is present.
     */
    sp->timeout = INT_MAX;
    cdf8:	00a00034 	movhi	r2,32768
    cdfc:	10bfffc4 	addi	r2,r2,-1
    ce00:	80800115 	stw	r2,4(r16)
  }

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ALARM_REGISTER(sp, sp->base);
}
    ce04:	dfc00117 	ldw	ra,4(sp)
    ce08:	dc000017 	ldw	r16,0(sp)
    ce0c:	dec00204 	addi	sp,sp,8
    ce10:	f800283a 	ret

0000ce14 <altera_avalon_jtag_uart_close>:
{
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
    ce14:	21800c17 	ldw	r6,48(r4)
    if (flags & O_NONBLOCK) {
    ce18:	2950000c 	andi	r5,r5,16384
{
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
    ce1c:	20800d17 	ldw	r2,52(r4)
    ce20:	11800626 	beq	r2,r6,ce3c <altera_avalon_jtag_uart_close+0x28>
    ce24:	20c00917 	ldw	r3,36(r4)
    ce28:	20800117 	ldw	r2,4(r4)
    ce2c:	1880032e 	bgeu	r3,r2,ce3c <altera_avalon_jtag_uart_close+0x28>
    if (flags & O_NONBLOCK) {
    ce30:	283ffa26 	beq	r5,zero,ce1c <_gp+0xffff67ac>
      return -EWOULDBLOCK; 
    ce34:	00bffd44 	movi	r2,-11
    ce38:	f800283a 	ret
    }
  }

  return 0;
    ce3c:	0005883a 	mov	r2,zero
}
    ce40:	f800283a 	ret

0000ce44 <altera_avalon_jtag_uart_write>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
    ce44:	defff304 	addi	sp,sp,-52
    ce48:	df000b15 	stw	fp,44(sp)
    ce4c:	ddc00a15 	stw	r23,40(sp)
    ce50:	dd800915 	stw	r22,36(sp)
    ce54:	dd400815 	stw	r21,32(sp)
    ce58:	dcc00615 	stw	r19,24(sp)
    ce5c:	dc800515 	stw	r18,20(sp)
    ce60:	dc400415 	stw	r17,16(sp)
    ce64:	382f883a 	mov	r23,r7
    ce68:	dfc00c15 	stw	ra,48(sp)
    ce6c:	dd000715 	stw	r20,28(sp)
    ce70:	dc000315 	stw	r16,12(sp)
    ce74:	2025883a 	mov	r18,r4
    ce78:	282b883a 	mov	r21,r5
    ce7c:	3027883a 	mov	r19,r6
    ce80:	2823883a 	mov	r17,r5
  /* Remove warning at optimisation level 03 by seting out to 0 */
  unsigned int in, out=0;
    ce84:	002d883a 	mov	r22,zero
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
    ce88:	073fff84 	movi	fp,-2
     * some has been sent 
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
    {
      if (flags & O_NONBLOCK)
    ce8c:	39d0000c 	andi	r7,r7,16384
        break;

      if (n > count)
        n = count;

      memcpy(sp->tx_buf + in, ptr, n);
    ce90:	22020e04 	addi	r8,r4,2104
      if (in < out)
        n = out - 1 - in;
      else if (out > 0)
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;
    ce94:	0241ffc4 	movi	r9,2047
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
    ce98:	04c01d0e 	bge	zero,r19,cf10 <altera_avalon_jtag_uart_write+0xcc>
    {
      /* We need a stable value of the out pointer to calculate the space available */
      in  = sp->tx_in;
    ce9c:	95000c17 	ldw	r20,48(r18)
      out = sp->tx_out;
    cea0:	95800d17 	ldw	r22,52(r18)

      if (in < out)
    cea4:	a580022e 	bgeu	r20,r22,ceb0 <altera_avalon_jtag_uart_write+0x6c>
        n = out - 1 - in;
    cea8:	b0ffffc4 	addi	r3,r22,-1
    ceac:	00000206 	br	ceb8 <altera_avalon_jtag_uart_write+0x74>
      else if (out > 0)
    ceb0:	b0000326 	beq	r22,zero,cec0 <altera_avalon_jtag_uart_write+0x7c>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
    ceb4:	00c20004 	movi	r3,2048
    ceb8:	1d21c83a 	sub	r16,r3,r20
    cebc:	00000106 	br	cec4 <altera_avalon_jtag_uart_write+0x80>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;
    cec0:	4d21c83a 	sub	r16,r9,r20

      if (n == 0)
    cec4:	80001226 	beq	r16,zero,cf10 <altera_avalon_jtag_uart_write+0xcc>
    cec8:	9c00012e 	bgeu	r19,r16,ced0 <altera_avalon_jtag_uart_write+0x8c>
    cecc:	9821883a 	mov	r16,r19
        break;

      if (n > count)
        n = count;

      memcpy(sp->tx_buf + in, ptr, n);
    ced0:	800d883a 	mov	r6,r16
    ced4:	880b883a 	mov	r5,r17
    ced8:	4509883a 	add	r4,r8,r20
      ptr   += n;
    cedc:	8c23883a 	add	r17,r17,r16
      count -= n;
    cee0:	9c27c83a 	sub	r19,r19,r16

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
    cee4:	a421883a 	add	r16,r20,r16
        break;

      if (n > count)
        n = count;

      memcpy(sp->tx_buf + in, ptr, n);
    cee8:	d9c00015 	stw	r7,0(sp)
    ceec:	da000115 	stw	r8,4(sp)
    cef0:	da400215 	stw	r9,8(sp)
      ptr   += n;
      count -= n;

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
    cef4:	8401ffcc 	andi	r16,r16,2047
        break;

      if (n > count)
        n = count;

      memcpy(sp->tx_buf + in, ptr, n);
    cef8:	000d2180 	call	d218 <memcpy>
      ptr   += n;
      count -= n;

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
    cefc:	da400217 	ldw	r9,8(sp)
    cf00:	94000c15 	stw	r16,48(r18)
    cf04:	da000117 	ldw	r8,4(sp)
    cf08:	d9c00017 	ldw	r7,0(sp)
    cf0c:	003fe206 	br	ce98 <_gp+0xffff6828>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
    cf10:	0007303a 	rdctl	r3,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
    cf14:	1f04703a 	and	r2,r3,fp
    cf18:	1001703a 	wrctl	status,r2
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
    cf1c:	90800817 	ldw	r2,32(r18)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
    cf20:	91000017 	ldw	r4,0(r18)
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
    cf24:	10800094 	ori	r2,r2,2
    cf28:	90800815 	stw	r2,32(r18)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
    cf2c:	20800135 	stwio	r2,4(r4)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
    cf30:	1801703a 	wrctl	status,r3
    /* 
     * If there is any data left then either return now or block until 
     * some has been sent 
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
    cf34:	04c0080e 	bge	zero,r19,cf58 <altera_avalon_jtag_uart_write+0x114>
    {
      if (flags & O_NONBLOCK)
    cf38:	3800101e 	bne	r7,zero,cf7c <altera_avalon_jtag_uart_write+0x138>
      /*
       * No OS present: Always wait for data to be removed from buffer.  Once
       * the interrupt routine has removed some data then we will be able to
       * insert some more.
       */
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
    cf3c:	90c00d17 	ldw	r3,52(r18)
    cf40:	90800917 	ldw	r2,36(r18)
    cf44:	b0c0021e 	bne	r22,r3,cf50 <altera_avalon_jtag_uart_write+0x10c>
    cf48:	90c00117 	ldw	r3,4(r18)
    cf4c:	10fffb36 	bltu	r2,r3,cf3c <_gp+0xffff68cc>
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
    cf50:	103fd126 	beq	r2,zero,ce98 <_gp+0xffff6828>
    cf54:	00000606 	br	cf70 <altera_avalon_jtag_uart_write+0x12c>
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);

  if (ptr != start)
    cf58:	8d400226 	beq	r17,r21,cf64 <altera_avalon_jtag_uart_write+0x120>
    return ptr - start;
    cf5c:	8d45c83a 	sub	r2,r17,r21
    cf60:	00000806 	br	cf84 <altera_avalon_jtag_uart_write+0x140>
  else if (flags & O_NONBLOCK)
    cf64:	bdd0000c 	andi	r23,r23,16384
    cf68:	b8000226 	beq	r23,zero,cf74 <altera_avalon_jtag_uart_write+0x130>
    cf6c:	00000406 	br	cf80 <altera_avalon_jtag_uart_write+0x13c>
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);

  if (ptr != start)
    cf70:	8d7ffa1e 	bne	r17,r21,cf5c <_gp+0xffff68ec>
    sp->tx_out = sp->tx_in = 0;
    return ptr - start + count;
  }
#endif
  else
    return -EIO; /* Host not connected */
    cf74:	00bffec4 	movi	r2,-5
    cf78:	00000206 	br	cf84 <altera_avalon_jtag_uart_write+0x140>
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);

  if (ptr != start)
    cf7c:	8d7ff71e 	bne	r17,r21,cf5c <_gp+0xffff68ec>
    return ptr - start;
  else if (flags & O_NONBLOCK)
    return -EWOULDBLOCK;
    cf80:	00bffd44 	movi	r2,-11
    return ptr - start + count;
  }
#endif
  else
    return -EIO; /* Host not connected */
}
    cf84:	dfc00c17 	ldw	ra,48(sp)
    cf88:	df000b17 	ldw	fp,44(sp)
    cf8c:	ddc00a17 	ldw	r23,40(sp)
    cf90:	dd800917 	ldw	r22,36(sp)
    cf94:	dd400817 	ldw	r21,32(sp)
    cf98:	dd000717 	ldw	r20,28(sp)
    cf9c:	dcc00617 	ldw	r19,24(sp)
    cfa0:	dc800517 	ldw	r18,20(sp)
    cfa4:	dc400417 	ldw	r17,16(sp)
    cfa8:	dc000317 	ldw	r16,12(sp)
    cfac:	dec00d04 	addi	sp,sp,52
    cfb0:	f800283a 	ret

0000cfb4 <alt_alarm_start>:
                     void* context)
{
  alt_irq_context irq_context;
  alt_u32 current_nticks = 0;
  
  if (alt_ticks_per_second ())
    cfb4:	d0a45217 	ldw	r2,-28344(gp)
    cfb8:	10001a26 	beq	r2,zero,d024 <alt_alarm_start+0x70>
  {
    if (alarm)
    cfbc:	20001b26 	beq	r4,zero,d02c <alt_alarm_start+0x78>
    {
      alarm->callback = callback;
    cfc0:	21800315 	stw	r6,12(r4)
      alarm->context  = context;
    cfc4:	21c00515 	stw	r7,20(r4)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
    cfc8:	0007303a 	rdctl	r3,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
    cfcc:	00bfff84 	movi	r2,-2
    cfd0:	1884703a 	and	r2,r3,r2
    cfd4:	1001703a 	wrctl	status,r2
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
    cfd8:	d0a45117 	ldw	r2,-28348(gp)
 
      irq_context = alt_irq_disable_all ();
      
      current_nticks = alt_nticks();
      
      alarm->time = nticks + current_nticks + 1; 
    cfdc:	11800044 	addi	r6,r2,1
    cfe0:	314b883a 	add	r5,r6,r5
    cfe4:	21400215 	stw	r5,8(r4)
      /* 
       * If the desired alarm time causes a roll-over, set the rollover
       * flag. This will prevent the subsequent tick event from causing
       * an alarm too early.
       */
      if(alarm->time < current_nticks)
    cfe8:	2880032e 	bgeu	r5,r2,cff8 <alt_alarm_start+0x44>
      {
        alarm->rollover = 1;
    cfec:	00800044 	movi	r2,1
    cff0:	20800405 	stb	r2,16(r4)
    cff4:	00000106 	br	cffc <alt_alarm_start+0x48>
      }
      else
      {
        alarm->rollover = 0;
    cff8:	20000405 	stb	zero,16(r4)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
    cffc:	d0a00904 	addi	r2,gp,-32732
    d000:	20800115 	stw	r2,4(r4)
  entry->next     = list->next;
    d004:	d0a00917 	ldw	r2,-32732(gp)
    d008:	20800015 	stw	r2,0(r4)

  list->next->previous = entry;
    d00c:	d0a00917 	ldw	r2,-32732(gp)
  list->next           = entry;
    d010:	d1200915 	stw	r4,-32732(gp)
                alt_llist* entry)
{
  entry->previous = list;
  entry->next     = list->next;

  list->next->previous = entry;
    d014:	11000115 	stw	r4,4(r2)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
    d018:	1801703a 	wrctl	status,r3
      }
    
      alt_llist_insert (&alt_alarm_list, &alarm->llist);
      alt_irq_enable_all (irq_context);

      return 0;
    d01c:	0005883a 	mov	r2,zero
    d020:	f800283a 	ret
      return -EINVAL;
    }
  }
  else
  {
    return -ENOTSUP;
    d024:	00bfde84 	movi	r2,-134
    d028:	f800283a 	ret

      return 0;
    }
    else
    {
      return -EINVAL;
    d02c:	00bffa84 	movi	r2,-22
  }
  else
  {
    return -ENOTSUP;
  }
}
    d030:	f800283a 	ret

0000d034 <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
    d034:	f800283a 	ret

0000d038 <alt_dev_null_write>:
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
  return len;
}
    d038:	3005883a 	mov	r2,r6
    d03c:	f800283a 	ret

0000d040 <alt_dev_llist_insert>:
{
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
    d040:	20000226 	beq	r4,zero,d04c <alt_dev_llist_insert+0xc>
    d044:	20800217 	ldw	r2,8(r4)
    d048:	1000101e 	bne	r2,zero,d08c <alt_dev_llist_insert+0x4c>

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  return ((alt_errno) ? alt_errno() : &errno);
    d04c:	d0a00817 	ldw	r2,-32736(gp)
    d050:	10000926 	beq	r2,zero,d078 <alt_dev_llist_insert+0x38>
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
    d054:	deffff04 	addi	sp,sp,-4
    d058:	dfc00015 	stw	ra,0(sp)
    d05c:	103ee83a 	callr	r2
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
  {
    ALT_ERRNO = EINVAL;
    d060:	00c00584 	movi	r3,22
    d064:	10c00015 	stw	r3,0(r2)
    return -EINVAL;
    d068:	00bffa84 	movi	r2,-22
   */
  
  alt_llist_insert(list, &dev->llist);

  return 0;  
}
    d06c:	dfc00017 	ldw	ra,0(sp)
    d070:	dec00104 	addi	sp,sp,4
    d074:	f800283a 	ret
    d078:	d0a45404 	addi	r2,gp,-28336
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
  {
    ALT_ERRNO = EINVAL;
    d07c:	00c00584 	movi	r3,22
    d080:	10c00015 	stw	r3,0(r2)
    return -EINVAL;
    d084:	00bffa84 	movi	r2,-22
   */
  
  alt_llist_insert(list, &dev->llist);

  return 0;  
}
    d088:	f800283a 	ret

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
  entry->next     = list->next;
    d08c:	28800017 	ldw	r2,0(r5)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
    d090:	21400115 	stw	r5,4(r4)
  entry->next     = list->next;
    d094:	20800015 	stw	r2,0(r4)

  list->next->previous = entry;
    d098:	28800017 	ldw	r2,0(r5)
    d09c:	11000115 	stw	r4,4(r2)
  list->next           = entry;
    d0a0:	29000015 	stw	r4,0(r5)
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);

  return 0;  
    d0a4:	0005883a 	mov	r2,zero
    d0a8:	f800283a 	ret

0000d0ac <alt_icache_flush_all>:
/*
 * alt_icache_flush_all() is called to flush the entire instruction cache.
 */

void alt_icache_flush_all (void)
{
    d0ac:	f800283a 	ret

0000d0b0 <alt_alarm_stop>:
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
    d0b0:	0007303a 	rdctl	r3,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
    d0b4:	00bfff84 	movi	r2,-2
    d0b8:	1884703a 	and	r2,r3,r2
    d0bc:	1001703a 	wrctl	status,r2
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
    d0c0:	21400117 	ldw	r5,4(r4)
    d0c4:	20800017 	ldw	r2,0(r4)
    d0c8:	11400115 	stw	r5,4(r2)
  entry->previous->next = entry->next;
    d0cc:	21400117 	ldw	r5,4(r4)
    d0d0:	28800015 	stw	r2,0(r5)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
    d0d4:	21000115 	stw	r4,4(r4)
  entry->next     = entry;
    d0d8:	21000015 	stw	r4,0(r4)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
    d0dc:	1801703a 	wrctl	status,r3
    d0e0:	f800283a 	ret

0000d0e4 <alt_tick>:

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
    d0e4:	d0a45117 	ldw	r2,-28348(gp)
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
    d0e8:	defffb04 	addi	sp,sp,-20
    d0ec:	dc000015 	stw	r16,0(sp)
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
    d0f0:	d4200917 	ldw	r16,-32732(gp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
    d0f4:	10800044 	addi	r2,r2,1
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
    d0f8:	dc800215 	stw	r18,8(sp)
    d0fc:	dc400115 	stw	r17,4(sp)
    d100:	dfc00415 	stw	ra,16(sp)
    d104:	dcc00315 	stw	r19,12(sp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
    d108:	d0a45115 	stw	r2,-28348(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
    d10c:	d4600904 	addi	r17,gp,-32732
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
        {
          alarm->rollover = 1;
    d110:	04800044 	movi	r18,1

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
    d114:	84401a26 	beq	r16,r17,d180 <alt_tick+0x9c>
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
    d118:	80800403 	ldbu	r2,16(r16)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
  {
    next = (alt_alarm*) alarm->llist.next;
    d11c:	84c00017 	ldw	r19,0(r16)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
    d120:	10000326 	beq	r2,zero,d130 <alt_tick+0x4c>
    d124:	d0a45117 	ldw	r2,-28348(gp)
    d128:	1000011e 	bne	r2,zero,d130 <alt_tick+0x4c>
    {
      alarm->rollover = 0;
    d12c:	80000405 	stb	zero,16(r16)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
    d130:	d0e45117 	ldw	r3,-28348(gp)
    d134:	80800217 	ldw	r2,8(r16)
    d138:	18800f36 	bltu	r3,r2,d178 <alt_tick+0x94>
    d13c:	80800403 	ldbu	r2,16(r16)
    d140:	10000d1e 	bne	r2,zero,d178 <alt_tick+0x94>
    {
      next_callback = alarm->callback (alarm->context);
    d144:	80800317 	ldw	r2,12(r16)
    d148:	81000517 	ldw	r4,20(r16)
    d14c:	103ee83a 	callr	r2

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
    d150:	1000031e 	bne	r2,zero,d160 <alt_tick+0x7c>
      {
        alt_alarm_stop (alarm);
    d154:	8009883a 	mov	r4,r16
    d158:	000d0b00 	call	d0b0 <alt_alarm_stop>
    d15c:	00000606 	br	d178 <alt_tick+0x94>
      }
      else
      {
        alarm->time += next_callback;
    d160:	80c00217 	ldw	r3,8(r16)
    d164:	10c5883a 	add	r2,r2,r3
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
    d168:	d0e45117 	ldw	r3,-28348(gp)
      {
        alt_alarm_stop (alarm);
      }
      else
      {
        alarm->time += next_callback;
    d16c:	80800215 	stw	r2,8(r16)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
    d170:	10c0012e 	bgeu	r2,r3,d178 <alt_tick+0x94>
        {
          alarm->rollover = 1;
    d174:	84800405 	stb	r18,16(r16)
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
    d178:	9821883a 	mov	r16,r19
    d17c:	003fe506 	br	d114 <_gp+0xffff6aa4>
  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
}
    d180:	dfc00417 	ldw	ra,16(sp)
    d184:	dcc00317 	ldw	r19,12(sp)
    d188:	dc800217 	ldw	r18,8(sp)
    d18c:	dc400117 	ldw	r17,4(sp)
    d190:	dc000017 	ldw	r16,0(sp)
    d194:	dec00504 	addi	sp,sp,20
    d198:	f800283a 	ret

0000d19c <altera_nios2_gen2_irq_init>:
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
    NIOS2_WRITE_IENABLE(0);
    d19c:	000170fa 	wrctl	ienable,zero
    d1a0:	f800283a 	ret

0000d1a4 <alt_exception_cause_generated_bad_addr>:
 *         0: BADADDR is not valid
 */
int 
alt_exception_cause_generated_bad_addr(alt_exception_cause cause)
{
  switch (cause) {
    d1a4:	213ffe84 	addi	r4,r4,-6
    d1a8:	008003c4 	movi	r2,15
    d1ac:	11001636 	bltu	r2,r4,d208 <alt_exception_cause_generated_bad_addr+0x64>
    d1b0:	200890ba 	slli	r4,r4,2
    d1b4:	00800074 	movhi	r2,1
    d1b8:	10b47204 	addi	r2,r2,-11832
    d1bc:	2089883a 	add	r4,r4,r2
    d1c0:	20800017 	ldw	r2,0(r4)
    d1c4:	1000683a 	jmp	r2
    d1c8:	0000d210 	cmplti	zero,zero,840
    d1cc:	0000d210 	cmplti	zero,zero,840
    d1d0:	0000d208 	cmpgei	zero,zero,840
    d1d4:	0000d208 	cmpgei	zero,zero,840
    d1d8:	0000d208 	cmpgei	zero,zero,840
    d1dc:	0000d210 	cmplti	zero,zero,840
    d1e0:	0000d208 	cmpgei	zero,zero,840
    d1e4:	0000d208 	cmpgei	zero,zero,840
    d1e8:	0000d210 	cmplti	zero,zero,840
    d1ec:	0000d210 	cmplti	zero,zero,840
    d1f0:	0000d208 	cmpgei	zero,zero,840
    d1f4:	0000d210 	cmplti	zero,zero,840
    d1f8:	0000d208 	cmpgei	zero,zero,840
    d1fc:	0000d208 	cmpgei	zero,zero,840
    d200:	0000d208 	cmpgei	zero,zero,840
    d204:	0000d210 	cmplti	zero,zero,840
  case NIOS2_EXCEPTION_ECC_DATA_ERR:
    return 1;

  case NIOS2_EXCEPTION_TLB_MISS:
  case NIOS2_EXCEPTION_ECC_TLB_ERR:
    return 0;
    d208:	0005883a 	mov	r2,zero
    d20c:	f800283a 	ret
  case NIOS2_EXCEPTION_MISALIGNED_TARGET_PC:
  case NIOS2_EXCEPTION_TLB_READ_PERM_VIOLATION:
  case NIOS2_EXCEPTION_TLB_WRITE_PERM_VIOLATION:
  case NIOS2_EXCEPTION_MPU_DATA_REGION_VIOLATION:
  case NIOS2_EXCEPTION_ECC_DATA_ERR:
    return 1;
    d210:	00800044 	movi	r2,1
    return 0;

  default:
    return 0;
  }
}
    d214:	f800283a 	ret

0000d218 <memcpy>:
    d218:	defffd04 	addi	sp,sp,-12
    d21c:	dfc00215 	stw	ra,8(sp)
    d220:	dc400115 	stw	r17,4(sp)
    d224:	dc000015 	stw	r16,0(sp)
    d228:	00c003c4 	movi	r3,15
    d22c:	2005883a 	mov	r2,r4
    d230:	1980452e 	bgeu	r3,r6,d348 <memcpy+0x130>
    d234:	2906b03a 	or	r3,r5,r4
    d238:	18c000cc 	andi	r3,r3,3
    d23c:	1800441e 	bne	r3,zero,d350 <memcpy+0x138>
    d240:	347ffc04 	addi	r17,r6,-16
    d244:	8822d13a 	srli	r17,r17,4
    d248:	28c00104 	addi	r3,r5,4
    d24c:	23400104 	addi	r13,r4,4
    d250:	8820913a 	slli	r16,r17,4
    d254:	2b000204 	addi	r12,r5,8
    d258:	22c00204 	addi	r11,r4,8
    d25c:	84000504 	addi	r16,r16,20
    d260:	2a800304 	addi	r10,r5,12
    d264:	22400304 	addi	r9,r4,12
    d268:	2c21883a 	add	r16,r5,r16
    d26c:	2811883a 	mov	r8,r5
    d270:	200f883a 	mov	r7,r4
    d274:	41000017 	ldw	r4,0(r8)
    d278:	1fc00017 	ldw	ra,0(r3)
    d27c:	63c00017 	ldw	r15,0(r12)
    d280:	39000015 	stw	r4,0(r7)
    d284:	53800017 	ldw	r14,0(r10)
    d288:	6fc00015 	stw	ra,0(r13)
    d28c:	5bc00015 	stw	r15,0(r11)
    d290:	4b800015 	stw	r14,0(r9)
    d294:	18c00404 	addi	r3,r3,16
    d298:	39c00404 	addi	r7,r7,16
    d29c:	42000404 	addi	r8,r8,16
    d2a0:	6b400404 	addi	r13,r13,16
    d2a4:	63000404 	addi	r12,r12,16
    d2a8:	5ac00404 	addi	r11,r11,16
    d2ac:	52800404 	addi	r10,r10,16
    d2b0:	4a400404 	addi	r9,r9,16
    d2b4:	1c3fef1e 	bne	r3,r16,d274 <_gp+0xffff6c04>
    d2b8:	89c00044 	addi	r7,r17,1
    d2bc:	380e913a 	slli	r7,r7,4
    d2c0:	310003cc 	andi	r4,r6,15
    d2c4:	02c000c4 	movi	r11,3
    d2c8:	11c7883a 	add	r3,r2,r7
    d2cc:	29cb883a 	add	r5,r5,r7
    d2d0:	5900212e 	bgeu	r11,r4,d358 <memcpy+0x140>
    d2d4:	1813883a 	mov	r9,r3
    d2d8:	2811883a 	mov	r8,r5
    d2dc:	200f883a 	mov	r7,r4
    d2e0:	42800017 	ldw	r10,0(r8)
    d2e4:	4a400104 	addi	r9,r9,4
    d2e8:	39ffff04 	addi	r7,r7,-4
    d2ec:	4abfff15 	stw	r10,-4(r9)
    d2f0:	42000104 	addi	r8,r8,4
    d2f4:	59fffa36 	bltu	r11,r7,d2e0 <_gp+0xffff6c70>
    d2f8:	213fff04 	addi	r4,r4,-4
    d2fc:	2008d0ba 	srli	r4,r4,2
    d300:	318000cc 	andi	r6,r6,3
    d304:	21000044 	addi	r4,r4,1
    d308:	2109883a 	add	r4,r4,r4
    d30c:	2109883a 	add	r4,r4,r4
    d310:	1907883a 	add	r3,r3,r4
    d314:	290b883a 	add	r5,r5,r4
    d318:	30000626 	beq	r6,zero,d334 <memcpy+0x11c>
    d31c:	198d883a 	add	r6,r3,r6
    d320:	29c00003 	ldbu	r7,0(r5)
    d324:	18c00044 	addi	r3,r3,1
    d328:	29400044 	addi	r5,r5,1
    d32c:	19ffffc5 	stb	r7,-1(r3)
    d330:	19bffb1e 	bne	r3,r6,d320 <_gp+0xffff6cb0>
    d334:	dfc00217 	ldw	ra,8(sp)
    d338:	dc400117 	ldw	r17,4(sp)
    d33c:	dc000017 	ldw	r16,0(sp)
    d340:	dec00304 	addi	sp,sp,12
    d344:	f800283a 	ret
    d348:	2007883a 	mov	r3,r4
    d34c:	003ff206 	br	d318 <_gp+0xffff6ca8>
    d350:	2007883a 	mov	r3,r4
    d354:	003ff106 	br	d31c <_gp+0xffff6cac>
    d358:	200d883a 	mov	r6,r4
    d35c:	003fee06 	br	d318 <_gp+0xffff6ca8>

0000d360 <strlen>:
    d360:	208000cc 	andi	r2,r4,3
    d364:	10002026 	beq	r2,zero,d3e8 <strlen+0x88>
    d368:	20800007 	ldb	r2,0(r4)
    d36c:	10002026 	beq	r2,zero,d3f0 <strlen+0x90>
    d370:	2005883a 	mov	r2,r4
    d374:	00000206 	br	d380 <strlen+0x20>
    d378:	10c00007 	ldb	r3,0(r2)
    d37c:	18001826 	beq	r3,zero,d3e0 <strlen+0x80>
    d380:	10800044 	addi	r2,r2,1
    d384:	10c000cc 	andi	r3,r2,3
    d388:	183ffb1e 	bne	r3,zero,d378 <_gp+0xffff6d08>
    d38c:	10c00017 	ldw	r3,0(r2)
    d390:	01ffbff4 	movhi	r7,65279
    d394:	39ffbfc4 	addi	r7,r7,-257
    d398:	00ca303a 	nor	r5,zero,r3
    d39c:	01a02074 	movhi	r6,32897
    d3a0:	19c7883a 	add	r3,r3,r7
    d3a4:	31a02004 	addi	r6,r6,-32640
    d3a8:	1946703a 	and	r3,r3,r5
    d3ac:	1986703a 	and	r3,r3,r6
    d3b0:	1800091e 	bne	r3,zero,d3d8 <strlen+0x78>
    d3b4:	10800104 	addi	r2,r2,4
    d3b8:	10c00017 	ldw	r3,0(r2)
    d3bc:	19cb883a 	add	r5,r3,r7
    d3c0:	00c6303a 	nor	r3,zero,r3
    d3c4:	28c6703a 	and	r3,r5,r3
    d3c8:	1986703a 	and	r3,r3,r6
    d3cc:	183ff926 	beq	r3,zero,d3b4 <_gp+0xffff6d44>
    d3d0:	00000106 	br	d3d8 <strlen+0x78>
    d3d4:	10800044 	addi	r2,r2,1
    d3d8:	10c00007 	ldb	r3,0(r2)
    d3dc:	183ffd1e 	bne	r3,zero,d3d4 <_gp+0xffff6d64>
    d3e0:	1105c83a 	sub	r2,r2,r4
    d3e4:	f800283a 	ret
    d3e8:	2005883a 	mov	r2,r4
    d3ec:	003fe706 	br	d38c <_gp+0xffff6d1c>
    d3f0:	0005883a 	mov	r2,zero
    d3f4:	f800283a 	ret
